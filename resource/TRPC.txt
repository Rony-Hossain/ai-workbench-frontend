# Enhanced tRPC Backend Implementation Plan
## AI Workbench - Production-Ready Architecture

## üéØ Key Improvements Over Original Plan

### 1. **Enhanced Security**
- Input validation with Zod schemas
- Rate limiting for mutations
- Path traversal protection for file operations
- Database transaction support
- SQL injection prevention with prepared statements

### 2. **Better Error Handling**
- Custom error types with codes
- Detailed error messages for debugging
- Graceful fallbacks
- Error recovery strategies

### 3. **Performance Optimizations**
- Database connection pooling
- Query result caching
- Batch operations support
- Streaming for large file operations

### 4. **Developer Experience**
- Type-safe schemas for all inputs/outputs
- Comprehensive JSDoc comments
- Debug logging with levels
- OpenAPI documentation support

---

## üìÅ Project Structure

```
apps/workbench-desktop/src/api/
‚îú‚îÄ‚îÄ trpc/
‚îÇ   ‚îú‚îÄ‚îÄ context.ts          # Request context & DB access
‚îÇ   ‚îú‚îÄ‚îÄ middleware.ts       # Security & logging layers
‚îÇ   ‚îî‚îÄ‚îÄ init.ts            # tRPC initialization
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îú‚îÄ‚îÄ provider.router.ts  # AI provider management
‚îÇ   ‚îú‚îÄ‚îÄ agent.router.ts     # Agent definitions
‚îÇ   ‚îú‚îÄ‚îÄ chat.router.ts      # Conversation history
‚îÇ   ‚îú‚îÄ‚îÄ files.router.ts     # File system operations
‚îÇ   ‚îî‚îÄ‚îÄ terminal.router.ts  # Terminal control
‚îú‚îÄ‚îÄ schemas/               # Zod validation schemas
‚îÇ   ‚îú‚îÄ‚îÄ provider.schema.ts
‚îÇ   ‚îú‚îÄ‚îÄ agent.schema.ts
‚îÇ   ‚îú‚îÄ‚îÄ chat.schema.ts
‚îÇ   ‚îú‚îÄ‚îÄ files.schema.ts
‚îÇ   ‚îî‚îÄ‚îÄ terminal.schema.ts
‚îú‚îÄ‚îÄ services/              # Business logic layer
‚îÇ   ‚îú‚îÄ‚îÄ database.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ file-sandbox.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ terminal-manager.service.ts
‚îî‚îÄ‚îÄ router.ts              # Main router assembly
```

---

## üîß Implementation Guide

### **Phase 1: Foundation (Day 1)**

#### Step 1.1: tRPC Context Setup
**File:** `apps/workbench-desktop/src/api/trpc/context.ts`

```typescript
import { Database } from '../services/database.service';
import { inferAsyncReturnType } from '@trpc/server';

export interface Context {
  db: Database;
  userId?: string; // For future multi-user support
  requestId: string; // For request tracing
}

export const createContext = async (): Promise<Context> => {
  const db = Database.getInstance();
  
  return {
    db,
    requestId: crypto.randomUUID(),
  };
};

export type TRPCContext = inferAsyncReturnType<typeof createContext>;
```

#### Step 1.2: Enhanced Middleware
**File:** `apps/workbench-desktop/src/api/trpc/middleware.ts`

```typescript
import { initTRPC, TRPCError } from '@trpc/server';
import { TRPCContext } from './context';
import chalk from 'chalk'; // Optional: for colored logs

const t = initTRPC.context<TRPCContext>().create({
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError: error.cause instanceof Error ? error.cause.message : null,
      },
    };
  },
});

// 1. Request Logger - Logs all operations
const requestLogger = t.middleware(async ({ path, type, next, ctx }) => {
  const start = Date.now();
  console.log(chalk.blue(`[${ctx.requestId}] ‚Üí ${type.toUpperCase()} ${path}`));
  
  const result = await next();
  const duration = Date.now() - start;
  
  if (result.ok) {
    console.log(chalk.green(`[${ctx.requestId}] ‚úì ${path} (${duration}ms)`));
  } else {
    console.log(chalk.red(`[${ctx.requestId}] ‚úó ${path} (${duration}ms)`));
  }
  
  return result;
});

// 2. Audit Logger - Records mutations to audit log
const auditLogger = t.middleware(async ({ path, type, next, ctx, rawInput }) => {
  if (type === 'mutation') {
    // Log to audit table in database
    await ctx.db.query(
      `INSERT INTO audit_log (request_id, action, input, timestamp) VALUES (?, ?, ?, ?)`,
      [ctx.requestId, path, JSON.stringify(rawInput), Date.now()]
    );
  }
  
  return next();
});

// 3. Rate Limiter - Prevents abuse
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();

const rateLimiter = t.middleware(async ({ path, next, ctx }) => {
  const key = `${ctx.userId || 'anonymous'}:${path}`;
  const now = Date.now();
  const limit = 100; // 100 requests per minute
  const window = 60000; // 1 minute
  
  const record = rateLimitMap.get(key);
  
  if (!record || now > record.resetAt) {
    rateLimitMap.set(key, { count: 1, resetAt: now + window });
  } else if (record.count >= limit) {
    throw new TRPCError({
      code: 'TOO_MANY_REQUESTS',
      message: 'Rate limit exceeded. Please try again later.',
    });
  } else {
    record.count++;
  }
  
  return next();
});

// 4. Critical Action Guard - Extra protection for dangerous ops
const criticalGuard = t.middleware(async ({ path, next, rawInput }) => {
  const criticalActions = ['delete', 'destroy', 'clear', 'remove', 'kill'];
  const isCritical = criticalActions.some(action => path.includes(action));
  
  if (isCritical) {
    console.warn(chalk.yellow(`‚ö†Ô∏è  CRITICAL ACTION: ${path}`));
    
    // Future: Add confirmation token check
    // if (!rawInput.confirmToken) {
    //   throw new TRPCError({
    //     code: 'FORBIDDEN',
    //     message: 'Confirmation required for critical action',
    //   });
    // }
  }
  
  return next();
});

// 5. Transaction Wrapper - Auto-rollback on error
const transactionWrapper = t.middleware(async ({ next, ctx }) => {
  try {
    await ctx.db.query('BEGIN TRANSACTION');
    const result = await next();
    await ctx.db.query('COMMIT');
    return result;
  } catch (error) {
    await ctx.db.query('ROLLBACK');
    throw error;
  }
});

// Export procedures with different protection levels
export const router = t.router;
export const publicProcedure = t.procedure
  .use(requestLogger);

export const protectedProcedure = t.procedure
  .use(requestLogger)
  .use(auditLogger)
  .use(rateLimiter)
  .use(criticalGuard);

export const transactionalProcedure = t.procedure
  .use(requestLogger)
  .use(auditLogger)
  .use(transactionWrapper);
```

---

### **Phase 2: Schemas (Day 1-2)**

#### Step 2.1: Provider Schemas
**File:** `apps/workbench-desktop/src/api/schemas/provider.schema.ts`

```typescript
import { z } from 'zod';

export const providerTypeSchema = z.enum(['local', 'cloud', 'openai', 'anthropic']);

export const modelSchema = z.object({
  id: z.string(),
  name: z.string(),
  contextWindow: z.number().optional(),
  maxTokens: z.number().optional(),
});

export const createProviderSchema = z.object({
  name: z.string().min(1).max(100),
  type: providerTypeSchema,
  endpoint: z.string().url().optional(),
  apiKey: z.string().optional(),
  models: z.array(modelSchema),
  metadata: z.record(z.unknown()).optional(),
});

export const updateProviderSchema = createProviderSchema.partial().extend({
  id: z.string().uuid(),
});

export const deleteProviderSchema = z.object({
  id: z.string().uuid(),
});

export const providerOutputSchema = createProviderSchema.extend({
  id: z.string().uuid(),
  createdAt: z.number(),
  updatedAt: z.number(),
});
```

#### Step 2.2: Agent Schemas
**File:** `apps/workbench-desktop/src/api/schemas/agent.schema.ts`

```typescript
import { z } from 'zod';

export const agentRoleSchema = z.enum([
  'planner',
  'coder',
  'reviewer',
  'tester',
  'researcher',
  'coordinator'
]);

export const createAgentSchema = z.object({
  name: z.string().min(1).max(100),
  role: agentRoleSchema,
  modelId: z.string().uuid(),
  systemPrompt: z.string().min(10).max(10000),
  temperature: z.number().min(0).max(2).default(0.7),
  maxTokens: z.number().min(1).max(100000).optional(),
  tools: z.array(z.string()).default([]),
  metadata: z.record(z.unknown()).optional(),
});

export const updateAgentSchema = createAgentSchema.partial().extend({
  id: z.string().uuid(),
});

export const agentOutputSchema = createAgentSchema.extend({
  id: z.string().uuid(),
  createdAt: z.number(),
  updatedAt: z.number(),
  isActive: z.boolean(),
});
```

#### Step 2.3: Chat Schemas
**File:** `apps/workbench-desktop/src/api/schemas/chat.schema.ts`

```typescript
import { z } from 'zod';

export const messageRoleSchema = z.enum(['user', 'assistant', 'system', 'tool']);

export const messageSchema = z.object({
  role: messageRoleSchema,
  content: z.string(),
  name: z.string().optional(),
  toolCallId: z.string().optional(),
});

export const createConversationSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  agentIds: z.array(z.string().uuid()).optional(),
  metadata: z.record(z.unknown()).optional(),
});

export const sendMessageSchema = z.object({
  conversationId: z.string().uuid(),
  message: messageSchema,
  parentMessageId: z.string().uuid().optional(),
});

export const getHistorySchema = z.object({
  conversationId: z.string().uuid(),
  limit: z.number().min(1).max(1000).default(100),
  offset: z.number().min(0).default(0),
  beforeTimestamp: z.number().optional(),
});

export const messageOutputSchema = messageSchema.extend({
  id: z.string().uuid(),
  conversationId: z.string().uuid(),
  timestamp: z.number(),
  tokens: z.number().optional(),
});
```

#### Step 2.4: Files Schemas
**File:** `apps/workbench-desktop/src/api/schemas/files.schema.ts`

```typescript
import { z } from 'zod';

// Path validation to prevent traversal attacks
const safePathSchema = z.string()
  .refine(
    (path) => !path.includes('..') && !path.startsWith('/') && !path.includes('\\'),
    'Invalid path: must be relative and not contain ".."'
  );

export const readDirSchema = z.object({
  path: safePathSchema.optional(),
  includeHidden: z.boolean().default(false),
  recursive: z.boolean().default(false),
  maxDepth: z.number().min(1).max(10).default(3),
});

export const readFileSchema = z.object({
  path: safePathSchema,
  encoding: z.enum(['utf8', 'base64']).default('utf8'),
});

export const writeFileSchema = z.object({
  path: safePathSchema,
  content: z.string(),
  encoding: z.enum(['utf8', 'base64']).default('utf8'),
  createDirs: z.boolean().default(true),
});

export const deleteFileSchema = z.object({
  path: safePathSchema,
});

export const fileInfoSchema = z.object({
  name: z.string(),
  path: z.string(),
  type: z.enum(['file', 'directory']),
  size: z.number(),
  modifiedAt: z.number(),
  isReadable: z.boolean(),
  isWritable: z.boolean(),
});

export const directoryTreeSchema = z.object({
  name: z.string(),
  path: z.string(),
  type: z.literal('directory'),
  children: z.array(z.lazy(() => fileInfoSchema.or(directoryTreeSchema))),
});
```

#### Step 2.5: Terminal Schemas
**File:** `apps/workbench-desktop/src/api/schemas/terminal.schema.ts`

```typescript
import { z } from 'zod';

export const createTerminalSchema = z.object({
  cwd: z.string().optional(),
  cols: z.number().min(20).max(500).default(80),
  rows: z.number().min(10).max(100).default(24),
  shell: z.string().optional(), // e.g., 'bash', 'zsh', 'powershell'
  env: z.record(z.string()).optional(),
});

export const writeTerminalSchema = z.object({
  sessionId: z.string().uuid(),
  data: z.string(),
});

export const resizeTerminalSchema = z.object({
  sessionId: z.string().uuid(),
  cols: z.number().min(20).max(500),
  rows: z.number().min(10).max(100),
});

export const killTerminalSchema = z.object({
  sessionId: z.string().uuid(),
  signal: z.string().optional().default('SIGTERM'),
});

export const terminalOutputSchema = z.object({
  sessionId: z.string().uuid(),
  pid: z.number(),
  cwd: z.string(),
  isAlive: z.boolean(),
});
```

---

### **Phase 3: Routers (Day 2-3)**

#### Step 3.1: Provider Router
**File:** `apps/workbench-desktop/src/api/routers/provider.router.ts`

```typescript
import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import {
  createProviderSchema,
  updateProviderSchema,
  deleteProviderSchema,
  providerOutputSchema,
} from '../schemas/provider.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';

export const providerRouter = router({
  /**
   * List all registered AI providers
   */
  list: publicProcedure
    .output(z.array(providerOutputSchema))
    .query(async ({ ctx }) => {
      const rows = await ctx.db.query(
        `SELECT * FROM providers ORDER BY created_at DESC`
      );
      
      return rows.map(row => ({
        ...row,
        models: JSON.parse(row.models),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
      }));
    }),

  /**
   * Get a single provider by ID
   */
  getById: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(providerOutputSchema)
    .query(async ({ ctx, input }) => {
      const rows = await ctx.db.query(
        `SELECT * FROM providers WHERE id = ?`,
        [input.id]
      );
      
      if (rows.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      const row = rows[0];
      return {
        ...row,
        models: JSON.parse(row.models),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
      };
    }),

  /**
   * Create a new AI provider
   */
  create: protectedProcedure
    .input(createProviderSchema)
    .output(providerOutputSchema)
    .mutation(async ({ ctx, input }) => {
      const id = crypto.randomUUID();
      const now = Date.now();
      
      await ctx.db.query(
        `INSERT INTO providers (id, name, type, endpoint, api_key, models, metadata, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          input.name,
          input.type,
          input.endpoint || null,
          input.apiKey || null,
          JSON.stringify(input.models),
          JSON.stringify(input.metadata || {}),
          now,
          now,
        ]
      );
      
      return {
        id,
        ...input,
        createdAt: now,
        updatedAt: now,
      };
    }),

  /**
   * Update an existing provider
   */
  update: protectedProcedure
    .input(updateProviderSchema)
    .output(providerOutputSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;
      
      // Check if provider exists
      const existing = await ctx.db.query(
        `SELECT * FROM providers WHERE id = ?`,
        [id]
      );
      
      if (existing.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${id} not found`,
        });
      }
      
      const updateFields: string[] = [];
      const updateValues: any[] = [];
      
      if (updates.name) {
        updateFields.push('name = ?');
        updateValues.push(updates.name);
      }
      if (updates.type) {
        updateFields.push('type = ?');
        updateValues.push(updates.type);
      }
      if (updates.endpoint !== undefined) {
        updateFields.push('endpoint = ?');
        updateValues.push(updates.endpoint);
      }
      if (updates.apiKey !== undefined) {
        updateFields.push('api_key = ?');
        updateValues.push(updates.apiKey);
      }
      if (updates.models) {
        updateFields.push('models = ?');
        updateValues.push(JSON.stringify(updates.models));
      }
      if (updates.metadata) {
        updateFields.push('metadata = ?');
        updateValues.push(JSON.stringify(updates.metadata));
      }
      
      updateFields.push('updated_at = ?');
      updateValues.push(Date.now());
      updateValues.push(id);
      
      await ctx.db.query(
        `UPDATE providers SET ${updateFields.join(', ')} WHERE id = ?`,
        updateValues
      );
      
      // Fetch and return updated record
      const updated = await ctx.db.query(
        `SELECT * FROM providers WHERE id = ?`,
        [id]
      );
      
      const row = updated[0];
      return {
        ...row,
        models: JSON.parse(row.models),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
      };
    }),

  /**
   * Delete a provider (with safety checks)
   */
  delete: protectedProcedure
    .input(deleteProviderSchema)
    .output(z.object({ success: z.boolean(), deletedId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Check if any agents are using this provider
      const dependentAgents = await ctx.db.query(
        `SELECT COUNT(*) as count FROM agents WHERE model_id = ?`,
        [input.id]
      );
      
      if (dependentAgents[0].count > 0) {
        throw new TRPCError({
          code: 'PRECONDITION_FAILED',
          message: `Cannot delete provider: ${dependentAgents[0].count} agent(s) are using it`,
        });
      }
      
      const result = await ctx.db.query(
        `DELETE FROM providers WHERE id = ?`,
        [input.id]
      );
      
      if (result.changes === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      return { success: true, deletedId: input.id };
    }),

  /**
   * Test provider connection
   */
  testConnection: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(z.object({
      success: z.boolean(),
      latency: z.number().optional(),
      error: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Implementation depends on your provider client
      // This is a placeholder
      try {
        const provider = await ctx.db.query(
          `SELECT * FROM providers WHERE id = ?`,
          [input.id]
        );
        
        if (provider.length === 0) {
          throw new Error('Provider not found');
        }
        
        const start = Date.now();
        // TODO: Make actual test request to provider
        // await providerClient.test(provider[0]);
        const latency = Date.now() - start;
        
        return { success: true, latency };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        };
      }
    }),
});
```

#### Step 3.2: Agent Router
**File:** `apps/workbench-desktop/src/api/routers/agent.router.ts`

```typescript
import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import {
  createAgentSchema,
  updateAgentSchema,
  agentOutputSchema,
} from '../schemas/agent.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';

export const agentRouter = router({
  /**
   * List all agents with optional filtering
   */
  list: publicProcedure
    .input(z.object({
      role: z.enum(['planner', 'coder', 'reviewer', 'tester', 'researcher', 'coordinator']).optional(),
      isActive: z.boolean().optional(),
    }).optional())
    .output(z.array(agentOutputSchema))
    .query(async ({ ctx, input }) => {
      let query = 'SELECT * FROM agents WHERE 1=1';
      const params: any[] = [];
      
      if (input?.role) {
        query += ' AND role = ?';
        params.push(input.role);
      }
      
      if (input?.isActive !== undefined) {
        query += ' AND is_active = ?';
        params.push(input.isActive ? 1 : 0);
      }
      
      query += ' ORDER BY created_at DESC';
      
      const rows = await ctx.db.query(query, params);
      
      return rows.map(row => ({
        ...row,
        tools: JSON.parse(row.tools || '[]'),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
        isActive: Boolean(row.is_active),
      }));
    }),

  /**
   * Get agent by ID
   */
  getById: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(agentOutputSchema)
    .query(async ({ ctx, input }) => {
      const rows = await ctx.db.query(
        `SELECT * FROM agents WHERE id = ?`,
        [input.id]
      );
      
      if (rows.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Agent with ID ${input.id} not found`,
        });
      }
      
      const row = rows[0];
      return {
        ...row,
        tools: JSON.parse(row.tools || '[]'),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
        isActive: Boolean(row.is_active),
      };
    }),

  /**
   * Create a new agent
   */
  create: protectedProcedure
    .input(createAgentSchema)
    .output(agentOutputSchema)
    .mutation(async ({ ctx, input }) => {
      // Verify that the model exists
      const modelExists = await ctx.db.query(
        `SELECT id FROM providers WHERE id = ?`,
        [input.modelId]
      );
      
      if (modelExists.length === 0) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: `Model with ID ${input.modelId} does not exist`,
        });
      }
      
      const id = crypto.randomUUID();
      const now = Date.now();
      
      await ctx.db.query(
        `INSERT INTO agents (
          id, name, role, model_id, system_prompt, temperature, max_tokens,
          tools, metadata, is_active, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          input.name,
          input.role,
          input.modelId,
          input.systemPrompt,
          input.temperature,
          input.maxTokens || null,
          JSON.stringify(input.tools),
          JSON.stringify(input.metadata || {}),
          1, // is_active defaults to true
          now,
          now,
        ]
      );
      
      return {
        id,
        ...input,
        isActive: true,
        createdAt: now,
        updatedAt: now,
      };
    }),

  /**
   * Update an existing agent
   */
  update: protectedProcedure
    .input(updateAgentSchema)
    .output(agentOutputSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;
      
      // Check if agent exists
      const existing = await ctx.db.query(
        `SELECT * FROM agents WHERE id = ?`,
        [id]
      );
      
      if (existing.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Agent with ID ${id} not found`,
        });
      }
      
      const updateFields: string[] = [];
      const updateValues: any[] = [];
      
      if (updates.name) {
        updateFields.push('name = ?');
        updateValues.push(updates.name);
      }
      if (updates.role) {
        updateFields.push('role = ?');
        updateValues.push(updates.role);
      }
      if (updates.modelId) {
        // Verify model exists
        const modelExists = await ctx.db.query(
          `SELECT id FROM providers WHERE id = ?`,
          [updates.modelId]
        );
        if (modelExists.length === 0) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: `Model with ID ${updates.modelId} does not exist`,
          });
        }
        updateFields.push('model_id = ?');
        updateValues.push(updates.modelId);
      }
      if (updates.systemPrompt) {
        updateFields.push('system_prompt = ?');
        updateValues.push(updates.systemPrompt);
      }
      if (updates.temperature !== undefined) {
        updateFields.push('temperature = ?');
        updateValues.push(updates.temperature);
      }
      if (updates.maxTokens !== undefined) {
        updateFields.push('max_tokens = ?');
        updateValues.push(updates.maxTokens);
      }
      if (updates.tools) {
        updateFields.push('tools = ?');
        updateValues.push(JSON.stringify(updates.tools));
      }
      if (updates.metadata) {
        updateFields.push('metadata = ?');
        updateValues.push(JSON.stringify(updates.metadata));
      }
      
      updateFields.push('updated_at = ?');
      updateValues.push(Date.now());
      updateValues.push(id);
      
      await ctx.db.query(
        `UPDATE agents SET ${updateFields.join(', ')} WHERE id = ?`,
        updateValues
      );
      
      // Fetch and return updated record
      const updated = await ctx.db.query(
        `SELECT * FROM agents WHERE id = ?`,
        [id]
      );
      
      const row = updated[0];
      return {
        ...row,
        tools: JSON.parse(row.tools || '[]'),
        metadata: row.metadata ? JSON.parse(row.metadata) : {},
        isActive: Boolean(row.is_active),
      };
    }),

  /**
   * Toggle agent active status
   */
  toggleActive: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(z.object({ success: z.boolean(), isActive: z.boolean() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query(
        `UPDATE agents SET is_active = NOT is_active, updated_at = ? WHERE id = ?`,
        [Date.now(), input.id]
      );
      
      if (result.changes === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Agent with ID ${input.id} not found`,
        });
      }
      
      const updated = await ctx.db.query(
        `SELECT is_active FROM agents WHERE id = ?`,
        [input.id]
      );
      
      return {
        success: true,
        isActive: Boolean(updated[0].is_active),
      };
    }),

  /**
   * Delete an agent
   */
  delete: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(z.object({ success: z.boolean(), deletedId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query(
        `DELETE FROM agents WHERE id = ?`,
        [input.id]
      );
      
      if (result.changes === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Agent with ID ${input.id} not found`,
        });
      }
      
      return { success: true, deletedId: input.id };
    }),
});
```

#### Step 3.3: Chat Router
**File:** `apps/workbench-desktop/src/api/routers/chat.router.ts`

```typescript
import { router, publicProcedure, protectedProcedure } from '../   


// ==========================================
// CHAT ROUTER (Continued from Part 1)
// ==========================================
// File: apps/workbench-desktop/src/api/routers/chat.router.ts

import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import {
  createConversationSchema,
  sendMessageSchema,
  getHistorySchema,
  messageOutputSchema,
} from '../schemas/chat.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';

export const chatRouter = router({
  /**
   * List all conversations
   */
  listConversations: publicProcedure
    .input(z.object({
      limit: z.number().min(1).max(100).default(50),
      offset: z.number().min(0).default(0),
    }).optional())
    .query(async ({ ctx, input = {} }) => {
      const { limit = 50, offset = 0 } = input;
      
      const conversations = await ctx.db.query(
        `SELECT c.*, 
          (SELECT COUNT(*) FROM messages WHERE conversation_id = c.id) as message_count,
          (SELECT content FROM messages WHERE conversation_id = c.id ORDER BY timestamp DESC LIMIT 1) as last_message
         FROM conversations c
         ORDER BY c.updated_at DESC
         LIMIT ? OFFSET ?`,
        [limit, offset]
      );
      
      return conversations.map(conv => ({
        ...conv,
        agentIds: conv.agent_ids ? JSON.parse(conv.agent_ids) : [],
        metadata: conv.metadata ? JSON.parse(conv.metadata) : {},
      }));
    }),

  /**
   * Create a new conversation
   */
  createConversation: protectedProcedure
    .input(createConversationSchema)
    .mutation(async ({ ctx, input }) => {
      const id = crypto.randomUUID();
      const now = Date.now();
      
      await ctx.db.query(
        `INSERT INTO conversations (id, title, agent_ids, metadata, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [
          id,
          input.title || 'New Conversation',
          JSON.stringify(input.agentIds || []),
          JSON.stringify(input.metadata || {}),
          now,
          now,
        ]
      );
      
      return { id, ...input, createdAt: now, updatedAt: now };
    }),

  /**
   * Get conversation history with pagination
   */
  getHistory: publicProcedure
    .input(getHistorySchema)
    .output(z.object({
      messages: z.array(messageOutputSchema),
      hasMore: z.boolean(),
      total: z.number(),
    }))
    .query(async ({ ctx, input }) => {
      const { conversationId, limit, offset, beforeTimestamp } = input;
      
      // Check if conversation exists
      const convExists = await ctx.db.query(
        `SELECT id FROM conversations WHERE id = ?`,
        [conversationId]
      );
      
      if (convExists.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Conversation with ID ${conversationId} not found`,
        });
      }
      
      // Build query with optional timestamp filter
      let query = 'SELECT * FROM messages WHERE conversation_id = ?';
      const params: any[] = [conversationId];
      
      if (beforeTimestamp) {
        query += ' AND timestamp < ?';
        params.push(beforeTimestamp);
      }
      
      query += ' ORDER BY timestamp ASC LIMIT ? OFFSET ?';
      params.push(limit, offset);
      
      const messages = await ctx.db.query(query, params);
      
      // Get total count
      const countResult = await ctx.db.query(
        `SELECT COUNT(*) as total FROM messages WHERE conversation_id = ?`,
        [conversationId]
      );
      
      const total = countResult[0].total;
      const hasMore = offset + messages.length < total;
      
      return {
        messages: messages.map(msg => ({
          ...msg,
          role: msg.role,
        })),
        hasMore,
        total,
      };
    }),

  /**
   * Send a message and persist it
   */
  sendMessage: protectedProcedure
    .input(sendMessageSchema)
    .output(messageOutputSchema)
    .mutation(async ({ ctx, input }) => {
      const { conversationId, message, parentMessageId } = input;
      
      // Verify conversation exists
      const convExists = await ctx.db.query(
        `SELECT id FROM conversations WHERE id = ?`,
        [conversationId]
      );
      
      if (convExists.length === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Conversation with ID ${conversationId} not found`,
        });
      }
      
      const messageId = crypto.randomUUID();
      const now = Date.now();
      
      // Insert message
      await ctx.db.query(
        `INSERT INTO messages (
          id, conversation_id, role, content, name, tool_call_id, 
          parent_message_id, timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          messageId,
          conversationId,
          message.role,
          message.content,
          message.name || null,
          message.toolCallId || null,
          parentMessageId || null,
          now,
        ]
      );
      
      // Update conversation's updated_at timestamp
      await ctx.db.query(
        `UPDATE conversations SET updated_at = ? WHERE id = ?`,
        [now, conversationId]
      );
      
      // TODO: Trigger agent processing here if role is 'user'
      // if (message.role === 'user') {
      //   await agentOrchestrator.processMessage(conversationId, messageId);
      // }
      
      return {
        id: messageId,
        conversationId,
        ...message,
        timestamp: now,
      };
    }),

  /**
   * Clear conversation history (keeps conversation metadata)
   */
  clearHistory: protectedProcedure
    .input(z.object({ conversationId: z.string().uuid() }))
    .output(z.object({ success: z.boolean(), deletedCount: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query(
        `DELETE FROM messages WHERE conversation_id = ?`,
        [input.conversationId]
      );
      
      return {
        success: true,
        deletedCount: result.changes || 0,
      };
    }),

  /**
   * Delete entire conversation
   */
  deleteConversation: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .output(z.object({ success: z.boolean() }))
    .mutation(async ({ ctx, input }) => {
      // Delete messages first (foreign key constraint)
      await ctx.db.query(
        `DELETE FROM messages WHERE conversation_id = ?`,
        [input.id]
      );
      
      // Delete conversation
      const result = await ctx.db.query(
        `DELETE FROM conversations WHERE id = ?`,
        [input.id]
      );
      
      if (result.changes === 0) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Conversation with ID ${input.id} not found`,
        });
      }
      
      return { success: true };
    }),

  /**
   * Search messages across conversations
   */
  searchMessages: publicProcedure
    .input(z.object({
      query: z.string().min(1),
      conversationId: z.string().uuid().optional(),
      limit: z.number().min(1).max(100).default(20),
    }))
    .query(async ({ ctx, input }) => {
      let query = `
        SELECT m.*, c.title as conversation_title
        FROM messages m
        JOIN conversations c ON m.conversation_id = c.id
        WHERE m.content LIKE ?
      `;
      const params: any[] = [`%${input.query}%`];
      
      if (input.conversationId) {
        query += ' AND m.conversation_id = ?';
        params.push(input.conversationId);
      }
      
      query += ' ORDER BY m.timestamp DESC LIMIT ?';
      params.push(input.limit);
      
      const results = await ctx.db.query(query, params);
      
      return results;
    }),
});

// ==========================================
// FILES ROUTER
// ==========================================
// File: apps/workbench-desktop/src/api/routers/files.router.ts

import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import {
  readDirSchema,
  readFileSchema,
  writeFileSchema,
  deleteFileSchema,
  fileInfoSchema,
  directoryTreeSchema,
} from '../schemas/files.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import * as fs from 'fs/promises';
import * as path from 'path';

// Workspace root (configure this based on your app)
const WORKSPACE_ROOT = process.env.WORKSPACE_ROOT || process.cwd();

// Forbidden paths for security
const FORBIDDEN_PATHS = [
  'node_modules',
  '.git',
  '.env',
  '.env.local',
  'package-lock.json',
  'yarn.lock',
];

/**
 * Validates and resolves a safe path within the workspace
 */
function resolveSafePath(relativePath: string = ''): string {
  const resolved = path.resolve(WORKSPACE_ROOT, relativePath);
  
  // Ensure path is within workspace
  if (!resolved.startsWith(WORKSPACE_ROOT)) {
    throw new TRPCError({
      code: 'FORBIDDEN',
      message: 'Path traversal detected',
    });
  }
  
  // Check forbidden paths
  const relPath = path.relative(WORKSPACE_ROOT, resolved);
  for (const forbidden of FORBIDDEN_PATHS) {
    if (relPath.startsWith(forbidden) || relPath.includes(`/${forbidden}/`)) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Access to ${forbidden} is forbidden`,
      });
    }
  }
  
  return resolved;
}

export const filesRouter = router({
  /**
   * Read directory contents
   */
  readDir: publicProcedure
    .input(readDirSchema)
    .query(async ({ input }) => {
      const targetPath = resolveSafePath(input.path);
      
      try {
        const entries = await fs.readdir(targetPath, { withFileTypes: true });
        
        const results = await Promise.all(
          entries
            .filter(entry => {
              // Filter hidden files if requested
              if (!input.includeHidden && entry.name.startsWith('.')) {
                return false;
              }
              // Filter forbidden paths
              return !FORBIDDEN_PATHS.includes(entry.name);
            })
            .map(async entry => {
              const fullPath = path.join(targetPath, entry.name);
              const stats = await fs.stat(fullPath);
              const relativePath = path.relative(WORKSPACE_ROOT, fullPath);
              
              const fileInfo = {
                name: entry.name,
                path: relativePath,
                type: entry.isDirectory() ? 'directory' as const : 'file' as const,
                size: stats.size,
                modifiedAt: stats.mtimeMs,
                isReadable: true, // Could add actual permission checks
                isWritable: true,
              };
              
              // Recursively read subdirectories if requested
              if (input.recursive && entry.isDirectory() && input.maxDepth > 1) {
                // Implement recursive logic here
              }
              
              return fileInfo;
            })
        );
        
        return results;
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Directory not found: ${input.path}`,
          });
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to read directory: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Read file contents
   */
  readFile: publicProcedure
    .input(readFileSchema)
    .output(z.object({ content: z.string(), size: z.number() }))
    .query(async ({ input }) => {
      const targetPath = resolveSafePath(input.path);
      
      try {
        const stats = await fs.stat(targetPath);
        
        if (stats.isDirectory()) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Path is a directory, not a file',
          });
        }
        
        // Limit file size for safety (e.g., 10MB)
        const MAX_FILE_SIZE = 10 * 1024 * 1024;
        if (stats.size > MAX_FILE_SIZE) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: `File too large (max ${MAX_FILE_SIZE / 1024 / 1024}MB)`,
          });
        }
        
        const content = await fs.readFile(targetPath, input.encoding);
        
        return {
          content: content.toString(),
          size: stats.size,
        };
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `File not found: ${input.path}`,
          });
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to read file: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Write file contents
   */
  writeFile: protectedProcedure
    .input(writeFileSchema)
    .output(z.object({ success: z.boolean(), path: z.string() }))
    .mutation(async ({ input }) => {
      const targetPath = resolveSafePath(input.path);
      
      try {
        // Create parent directories if requested
        if (input.createDirs) {
          const dir = path.dirname(targetPath);
          await fs.mkdir(dir, { recursive: true });
        }
        
        await fs.writeFile(targetPath, input.content, input.encoding);
        
        return {
          success: true,
          path: path.relative(WORKSPACE_ROOT, targetPath),
        };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to write file: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Delete file or directory
   */
  deleteFile: protectedProcedure
    .input(deleteFileSchema)
    .output(z.object({ success: z.boolean() }))
    .mutation(async ({ input }) => {
      const targetPath = resolveSafePath(input.path);
      
      try {
        const stats = await fs.stat(targetPath);
        
        if (stats.isDirectory()) {
          await fs.rm(targetPath, { recursive: true, force: true });
        } else {
          await fs.unlink(targetPath);
        }
        
        return { success: true };
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Path not found: ${input.path}`,
          });
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to delete: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Get file/directory metadata
   */
  getMetadata: publicProcedure
    .input(z.object({ path: z.string() }))
    .query(async ({ input }) => {
      const targetPath = resolveSafePath(input.path);
      
      try {
        const stats = await fs.stat(targetPath);
        
        return {
          path: input.path,
          type: stats.isDirectory() ? 'directory' as const : 'file' as const,
          size: stats.size,
          createdAt: stats.birthtimeMs,
          modifiedAt: stats.mtimeMs,
          isReadable: true,
          isWritable: true,
        };
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Path not found: ${input.path}`,
          });
        }
        throw error;
      }
    }),
});

// ==========================================
// TERMINAL ROUTER
// ==========================================
// File: apps/workbench-desktop/src/api/routers/terminal.router.ts

import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import {
  createTerminalSchema,
  writeTerminalSchema,
  resizeTerminalSchema,
  killTerminalSchema,
  terminalOutputSchema,
} from '../schemas/terminal.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
// Assuming you have a TerminalManager service
// import { TerminalManager } from '../services/terminal-manager.service';

export const terminalRouter = router({
  /**
   * Create a new terminal session
   */
  create: protectedProcedure
    .input(createTerminalSchema)
    .output(terminalOutputSchema)
    .mutation(async ({ input }) => {
      try {
        // TODO: Replace with your actual TerminalManager implementation
        // const session = await TerminalManager.createSession({
        //   cwd: input.cwd || process.cwd(),
        //   cols: input.cols,
        //   rows: input.rows,
        //   shell: input.shell,
        //   env: input.env,
        // });
        
        // Placeholder response
        const sessionId = crypto.randomUUID();
        
        return {
          sessionId,
          pid: 12345, // Replace with actual PID
          cwd: input.cwd || process.cwd(),
          isAlive: true,
        };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to create terminal: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Write data to terminal
   */
  write: protectedProcedure
    .input(writeTerminalSchema)
    .output(z.object({ success: z.boolean() }))
    .mutation(async ({ input }) => {
      try {
        // TODO: Replace with actual implementation
        // await TerminalManager.write(input.sessionId, input.data);
        
        return { success: true };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to write to terminal: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Resize terminal
   */
  resize: protectedProcedure
    .input(resizeTerminalSchema)
    .output(z.object({ success: z.boolean() }))
    .mutation(async ({ input }) => {
      try {
        // TODO: Replace with actual implementation
        // await TerminalManager.resize(input.sessionId, input.cols, input.rows);
        
        return { success: true };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to resize terminal: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * Kill terminal session
   */
  kill: protectedProcedure
    .input(killTerminalSchema)
    .output(z.object({ success: z.boolean() }))
    .mutation(async ({ input }) => {
      try {
        // TODO: Replace with actual implementation
        // await TerminalManager.kill(input.sessionId, input.signal);
        
        return { success: true };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to kill terminal: ${(error as Error).message}`,
        });
      }
    }),

  /**
   * List active terminal sessions
   */
  listSessions: publicProcedure
    .output(z.array(terminalOutputSchema))
    .query(async () => {
      // TODO: Replace with actual implementation
      // const sessions = await TerminalManager.listSessions();
      
      return [];
    }),

  /**
   * Get terminal session status
   */
  getStatus: publicProcedure
    .input(z.object({ sessionId: z.string().uuid() }))
    .output(terminalOutputSchema)
    .query(async ({ input }) => {
      // TODO: Replace with actual implementation
      // const session = await TerminalManager.getSession(input.sessionId);
      
      // Placeholder
      return {
        sessionId: input.sessionId,
        pid: 12345,
        cwd: process.cwd(),
        isAlive: true,
      };
    }),
});

// ==========================================
// MAIN ROUTER ASSEMBLY
// ==========================================
// File: apps/workbench-desktop/src/api/router.ts

import { router } from './trpc/middleware';
import { providerRouter } from './routers/provider.router';
import { agentRouter } from './routers/agent.router';
import { chatRouter } from './routers/chat.router';
import { filesRouter } from './routers/files.router';
import { terminalRouter } from './routers/terminal.router';

export const appRouter = router({
  provider: providerRouter,
  agent: agentRouter,
  chat: chatRouter,
  files: filesRouter,
  terminal: terminalRouter,
});

export type AppRouter = typeof appRouter;



-- ==========================================
-- DATABASE SCHEMA FOR AI WORKBENCH
-- ==========================================
-- File: apps/workbench-desktop/src/api/database/schema.sql

-- Enable foreign keys
PRAGMA foreign_keys = ON;

-- ==========================================
-- PROVIDERS TABLE
-- ==========================================
CREATE TABLE IF NOT EXISTS providers (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK(type IN ('local', 'cloud', 'openai', 'anthropic')),
  endpoint TEXT,
  api_key TEXT,
  models TEXT NOT NULL, -- JSON array of model objects
  metadata TEXT, -- JSON object for additional data
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_providers_type ON providers(type);
CREATE INDEX idx_providers_created_at ON providers(created_at DESC);

-- ==========================================
-- AGENTS TABLE
-- ==========================================
CREATE TABLE IF NOT EXISTS agents (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  role TEXT NOT NULL CHECK(role IN ('planner', 'coder', 'reviewer', 'tester', 'researcher', 'coordinator')),
  model_id TEXT NOT NULL,
  system_prompt TEXT NOT NULL,
  temperature REAL DEFAULT 0.7,
  max_tokens INTEGER,
  tools TEXT DEFAULT '[]', -- JSON array of tool names
  metadata TEXT, -- JSON object
  is_active INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (model_id) REFERENCES providers(id) ON DELETE RESTRICT
);

CREATE INDEX idx_agents_role ON agents(role);
CREATE INDEX idx_agents_is_active ON agents(is_active);
CREATE INDEX idx_agents_model_id ON agents(model_id);

-- ==========================================
-- CONVERSATIONS TABLE
-- ==========================================
CREATE TABLE IF NOT EXISTS conversations (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL DEFAULT 'New Conversation',
  agent_ids TEXT, -- JSON array of agent IDs
  metadata TEXT, -- JSON object
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC);

-- ==========================================
-- MESSAGES TABLE
-- ==========================================
CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  conversation_id TEXT NOT NULL,
  role TEXT NOT NULL CHECK(role IN ('user', 'assistant', 'system', 'tool')),
  content TEXT NOT NULL,
  name TEXT, -- Optional: for tool or user names
  tool_call_id TEXT, -- For tool results
  parent_message_id TEXT, -- For threading
  tokens INTEGER, -- Token count for this message
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_message_id) REFERENCES messages(id) ON DELETE SET NULL
);

CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_timestamp ON messages(timestamp ASC);
CREATE INDEX idx_messages_role ON messages(role);
CREATE INDEX idx_messages_parent ON messages(parent_message_id);

-- Full-text search for messages
CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(
  content,
  content=messages,
  content_rowid=rowid
);

-- Triggers to keep FTS index up to date
CREATE TRIGGER IF NOT EXISTS messages_fts_insert AFTER INSERT ON messages BEGIN
  INSERT INTO messages_fts(rowid, content) VALUES (new.rowid, new.content);
END;

CREATE TRIGGER IF NOT EXISTS messages_fts_delete AFTER DELETE ON messages BEGIN
  DELETE FROM messages_fts WHERE rowid = old.rowid;
END;

CREATE TRIGGER IF NOT EXISTS messages_fts_update AFTER UPDATE ON messages BEGIN
  DELETE FROM messages_fts WHERE rowid = old.rowid;
  INSERT INTO messages_fts(rowid, content) VALUES (new.rowid, new.content);
END;

-- ==========================================
-- AUDIT LOG TABLE
-- ==========================================
CREATE TABLE IF NOT EXISTS audit_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  request_id TEXT NOT NULL,
  action TEXT NOT NULL,
  input TEXT, -- JSON
  user_id TEXT, -- For future multi-user support
  timestamp INTEGER NOT NULL,
  success INTEGER DEFAULT 1
);

CREATE INDEX idx_audit_timestamp ON audit_log(timestamp DESC);
CREATE INDEX idx_audit_action ON audit_log(action);
CREATE INDEX idx_audit_request_id ON audit_log(request_id);

-- ==========================================
-- SETTINGS TABLE (Key-Value Store)
-- ==========================================
CREATE TABLE IF NOT EXISTS settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at INTEGER NOT NULL
);

-- ==========================================
-- FILE METADATA TABLE (Optional: Track workspace files)
-- ==========================================
CREATE TABLE IF NOT EXISTS file_metadata (
  id TEXT PRIMARY KEY,
  path TEXT UNIQUE NOT NULL,
  size INTEGER NOT NULL,
  hash TEXT, -- File hash for change detection
  last_modified INTEGER NOT NULL,
  last_indexed INTEGER NOT NULL,
  metadata TEXT -- JSON object
);

CREATE INDEX idx_file_path ON file_metadata(path);
CREATE INDEX idx_file_last_modified ON file_metadata(last_modified DESC);

-- ==========================================
-- TERMINAL SESSIONS TABLE (Optional: Persist sessions)
-- ==========================================
CREATE TABLE IF NOT EXISTS terminal_sessions (
  id TEXT PRIMARY KEY,
  pid INTEGER NOT NULL,
  cwd TEXT NOT NULL,
  cols INTEGER NOT NULL,
  rows INTEGER NOT NULL,
  shell TEXT,
  created_at INTEGER NOT NULL,
  last_active INTEGER NOT NULL,
  is_alive INTEGER DEFAULT 1
);

CREATE INDEX idx_terminal_is_alive ON terminal_sessions(is_alive);

-- ==========================================
-- MIGRATION TRACKING
-- ==========================================
CREATE TABLE IF NOT EXISTS schema_migrations (
  version INTEGER PRIMARY KEY,
  applied_at INTEGER NOT NULL,
  description TEXT
);

-- Insert initial migration
INSERT OR IGNORE INTO schema_migrations (version, applied_at, description)
VALUES (1, strftime('%s', 'now') * 1000, 'Initial schema');

-- ==========================================
-- SAMPLE DATA (Optional - for testing)
-- ==========================================

-- Sample provider
INSERT OR IGNORE INTO providers (id, name, type, endpoint, models, created_at, updated_at)
VALUES (
  '00000000-0000-0000-0000-000000000001',
  'Local Swarm',
  'local',
  'http://localhost:8080',
  '[{"id":"llama-3-70b","name":"Llama 3 70B","contextWindow":8192,"maxTokens":4096}]',
  strftime('%s', 'now') * 1000,
  strftime('%s', 'now') * 1000
);

-- Sample agent
INSERT OR IGNORE INTO agents (id, name, role, model_id, system_prompt, created_at, updated_at)
VALUES (
  '00000000-0000-0000-0000-000000000002',
  'Senior Developer',
  'coder',
  '00000000-0000-0000-0000-000000000001',
  'You are an expert software engineer specializing in TypeScript, React, and Node.js.',
  strftime('%s', 'now') * 1000,
  strftime('%s', 'now') * 1000
);

-- ==========================================
-- VIEWS (Helpful queries)
-- ==========================================

-- View: Recent conversations with message counts
CREATE VIEW IF NOT EXISTS recent_conversations AS
SELECT 
  c.id,
  c.title,
  c.created_at,
  c.updated_at,
  COUNT(m.id) as message_count,
  MAX(m.timestamp) as last_message_time
FROM conversations c
LEFT JOIN messages m ON c.id = m.conversation_id
GROUP BY c.id
ORDER BY c.updated_at DESC;

-- View: Agent usage statistics
CREATE VIEW IF NOT EXISTS agent_stats AS
SELECT 
  a.id,
  a.name,
  a.role,
  COUNT(DISTINCT m.conversation_id) as conversations_participated,
  COUNT(m.id) as total_messages,
  SUM(m.tokens) as total_tokens
FROM agents a
LEFT JOIN messages m ON m.name = a.name AND m.role = 'assistant'
GROUP BY a.id;

-- ==========================================
-- STORED PROCEDURES (SQLite doesn't support these,
-- but here are common queries you might wrap in functions)
-- ==========================================

/*
-- Get conversation with full message history
SELECT 
  c.*,
  json_group_array(
    json_object(
      'id', m.id,
      'role', m.role,
      'content', m.content,
      'timestamp', m.timestamp
    )
  ) as messages
FROM conversations c
LEFT JOIN messages m ON c.id = m.conversation_id
WHERE c.id = ?
GROUP BY c.id;

-- Get agent with provider details
SELECT 
  a.*,
  p.name as provider_name,
  p.type as provider_type,
  p.endpoint as provider_endpoint
FROM agents a
JOIN providers p ON a.model_id = p.id
WHERE a.id = ?;

-- Search messages with context
SELECT 
  m.*,
  c.title as conversation_title,
  rank
FROM messages_fts
JOIN messages m ON messages_fts.rowid = m.rowid
JOIN conversations c ON m.conversation_id = c.id
WHERE messages_fts MATCH ?
ORDER BY rank
LIMIT ?;
*/

# üöÄ Implementation Checklist & Best Practices

## üìã Implementation Order (Follow This Sequence)

### **Week 1: Foundation**

#### Day 1-2: Database & Core Setup
- [ ] **Step 1.1**: Create database schema
  - Run `schema.sql` to initialize SQLite database
  - Verify all tables and indexes are created
  - Test with sample data
  
- [ ] **Step 1.2**: Database Service Layer
  ```typescript
  // File: apps/workbench-desktop/src/api/services/database.service.ts
  import Database from 'better-sqlite3';
  
  export class DatabaseService {
    private static instance: DatabaseService;
    private db: Database.Database;
    
    private constructor() {
      this.db = new Database('workbench.db');
      this.db.pragma('foreign_keys = ON');
    }
    
    static getInstance(): DatabaseService {
      if (!DatabaseService.instance) {
        DatabaseService.instance = new DatabaseService();
      }
      return DatabaseService.instance;
    }
    
    query(sql: string, params: any[] = []) {
      return this.db.prepare(sql).all(...params);
    }
    
    run(sql: string, params: any[] = []) {
      return this.db.prepare(sql).run(...params);
    }
  }
  ```

- [ ] **Step 1.3**: tRPC Context & Middleware
  - Create `context.ts` (from Part 1)
  - Create `middleware.ts` (from Part 1)
  - Test middleware logging

#### Day 3-4: Validation Schemas
- [ ] **Step 2.1**: Create all Zod schemas
  - `provider.schema.ts` ‚úì
  - `agent.schema.ts` ‚úì
  - `chat.schema.ts` ‚úì
  - `files.schema.ts` ‚úì
  - `terminal.schema.ts` ‚úì

- [ ] **Step 2.2**: Test schema validation
  ```typescript
  // Test file: schemas.test.ts
  import { createProviderSchema } from './schemas/provider.schema';
  
  const validProvider = {
    name: 'Test Provider',
    type: 'local',
    models: [{ id: 'test', name: 'Test Model' }]
  };
  
  const result = createProviderSchema.safeParse(validProvider);
  console.assert(result.success, 'Schema validation failed');
  ```

### **Week 2: Core Routers**

#### Day 5-6: Provider & Agent Routers
- [ ] **Step 3.1**: Implement Provider Router
  - Create `provider.router.ts`
  - Test CRUD operations
  - Add connection testing endpoint
  
- [ ] **Step 3.2**: Implement Agent Router
  - Create `agent.router.ts`
  - Test CRUD operations
  - Verify foreign key constraints

#### Day 7-8: Chat Router
- [ ] **Step 3.3**: Implement Chat Router
  - Create `chat.router.ts`
  - Test conversation creation
  - Test message persistence
  - Implement search functionality

### **Week 3: File System & Terminal**

#### Day 9-10: File System Router
- [ ] **Step 3.4**: Implement Files Router
  - Create `files.router.ts`
  - Implement path validation
  - Test read/write operations
  - Add security tests (path traversal)

#### Day 11-12: Terminal Router
- [ ] **Step 3.5**: Implement Terminal Router
  - Create terminal manager service
  - Integrate with `node-pty`
  - Test terminal creation/destruction
  - Implement session management

### **Week 4: Integration & Testing**

#### Day 13-14: Assembly & Frontend
- [ ] **Step 4.1**: Assemble Main Router
  - Create `router.ts`
  - Export `AppRouter` type
  
- [ ] **Step 4.2**: Frontend Client Setup
  ```typescript
  // File: libs/shared/client-api/src/lib/trpc.ts
  import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
  import type { AppRouter } from '@workbench/backend/api';
  
  export const trpc = createTRPCProxyClient<AppRouter>({
    links: [
      httpBatchLink({
        url: 'http://localhost:3000/trpc',
      }),
    ],
  });
  ```

#### Day 15-16: Testing & Documentation
- [ ] **Step 4.3**: Write integration tests
- [ ] **Step 4.4**: Add API documentation
- [ ] **Step 4.5**: Performance testing
- [ ] **Step 4.6**: Security audit

---

## üîí Security Best Practices

### 1. **Input Validation**
- ‚úÖ All inputs validated with Zod schemas
- ‚úÖ Path traversal protection for file operations
- ‚úÖ SQL injection prevention with prepared statements
- ‚úÖ Rate limiting on all mutations

### 2. **Database Safety**
- ‚úÖ Foreign key constraints enabled
- ‚úÖ Transactions for multi-step operations
- ‚úÖ Audit logging for all mutations
- ‚úÖ Cascading deletes properly configured

### 3. **File System Safety**
```typescript
// Always use workspace-relative paths
const WORKSPACE_ROOT = process.env.WORKSPACE_ROOT || process.cwd();

// Forbidden paths
const FORBIDDEN = [
  'node_modules',
  '.git',
  '.env',
  'package-lock.json',
];

// Validate every path
function validatePath(relativePath: string) {
  const absolute = path.resolve(WORKSPACE_ROOT, relativePath);
  if (!absolute.startsWith(WORKSPACE_ROOT)) {
    throw new Error('Path traversal detected');
  }
  return absolute;
}
```

### 4. **Terminal Safety**
- Sanitize environment variables
- Limit concurrent sessions
- Auto-kill orphaned processes
- Log all commands (audit trail)

---

## ‚ö° Performance Optimizations

### 1. **Database Indexing**
```sql
-- Already included in schema.sql
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_timestamp ON messages(timestamp ASC);
```

### 2. **Query Optimization**
```typescript
// Bad: N+1 queries
for (const conv of conversations) {
  const messages = await getMessages(conv.id);
}

// Good: Single query with join
const conversationsWithMessages = await db.query(`
  SELECT c.*, json_group_array(m.*) as messages
  FROM conversations c
  LEFT JOIN messages m ON c.id = m.conversation_id
  GROUP BY c.id
`);
```

### 3. **Caching Strategy**
```typescript
import { LRUCache } from 'lru-cache';

const fileCache = new LRUCache<string, string>({
  max: 100,
  ttl: 1000 * 60 * 5, // 5 minutes
});

// Use in file operations
async function readFileCached(path: string) {
  const cached = fileCache.get(path);
  if (cached) return cached;
  
  const content = await fs.readFile(path, 'utf8');
  fileCache.set(path, content);
  return content;
}
```

### 4. **Batch Operations**
```typescript
// Batch insert messages
const insertMessage = db.prepare(`
  INSERT INTO messages (id, conversation_id, role, content, timestamp)
  VALUES (?, ?, ?, ?, ?)
`);

const insertMany = db.transaction((messages) => {
  for (const msg of messages) {
    insertMessage.run(msg.id, msg.conversationId, msg.role, msg.content, msg.timestamp);
  }
});

insertMany(messageArray);
```

---

## üß™ Testing Strategy

### Unit Tests
```typescript
// provider.router.test.ts
import { appRouter } from './router';
import { createContext } from './trpc/context';

describe('Provider Router', () => {
  it('should create provider', async () => {
    const ctx = await createContext();
    const caller = appRouter.createCaller(ctx);
    
    const result = await caller.provider.create({
      name: 'Test',
      type: 'local',
      models: [{ id: 'test', name: 'Test' }],
    });
    
    expect(result.id).toBeDefined();
    expect(result.name).toBe('Test');
  });
});
```

### Integration Tests
```typescript
// e2e/chat-flow.test.ts
describe('Chat Flow', () => {
  it('should create conversation and send message', async () => {
    // 1. Create conversation
    const conv = await trpc.chat.createConversation.mutate({
      title: 'Test Chat',
    });
    
    // 2. Send message
    const msg = await trpc.chat.sendMessage.mutate({
      conversationId: conv.id,
      message: {
        role: 'user',
        content: 'Hello',
      },
    });
    
    // 3. Verify history
    const history = await trpc.chat.getHistory.query({
      conversationId: conv.id,
    });
    
    expect(history.messages).toHaveLength(1);
  });
});
```

---

## üìä Monitoring & Debugging

### 1. **Request Tracing**
```typescript
// Every request gets a unique ID
console.log(`[${ctx.requestId}] Processing request...`);
```

### 2. **Performance Monitoring**
```typescript
const performanceLogger = t.middleware(async ({ path, next }) => {
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  
  if (duration > 1000) {
    console.warn(`‚ö†Ô∏è Slow query: ${path} took ${duration}ms`);
  }
  
  return result;
});
```

### 3. **Error Tracking**
```typescript
// Integrate with Sentry or similar
import * as Sentry from '@sentry/node';

const errorHandler = t.middleware(async ({ next }) => {
  try {
    return await next();
  } catch (error) {
    Sentry.captureException(error);
    throw error;
  }
});
```

---

## üîß Additional Utilities

### Database Migrations
```typescript
// File: api/services/migrations.ts
export async function runMigrations(db: DatabaseService) {
  const migrations = [
    {
      version: 2,
      description: 'Add user preferences table',
      up: `CREATE TABLE user_preferences (...)`,
    },
    // Add more migrations
  ];
  
  for (const migration of migrations) {
    const applied = db.query(
      'SELECT version FROM schema_migrations WHERE version = ?',
      [migration.version]
    );
    
    if (applied.length === 0) {
      db.run(migration.up);
      db.run(
        'INSERT INTO schema_migrations (version, applied_at, description) VALUES (?, ?, ?)',
        [migration.version, Date.now(), migration.description]
      );
    }
  }
}
```

### Health Check Endpoint
```typescript
export const healthRouter = router({
  check: publicProcedure.query(async ({ ctx }) => {
    const dbCheck = await ctx.db.query('SELECT 1');
    
    return {
      status: 'healthy',
      timestamp: Date.now(),
      checks: {
        database: dbCheck.length > 0,
        // Add more checks
      },
    };
  }),
});
```

---

## üìö Resources

### Documentation Links
- [tRPC Documentation](https://trpc.io)
- [Zod Validation](https://zod.dev)
- [Better SQLite3](https://github.com/WiseLibs/better-sqlite3)
- [Node PTY](https://github.com/microsoft/node-pty)

### Recommended Libraries
- `better-sqlite3` - Fast SQLite3 bindings
- `zod` - Schema validation
- `chalk` - Colored console output
- `lru-cache` - In-memory caching
- `nanoid` - ID generation (alternative to UUID)

---

## ‚úÖ Final Checklist

Before going to production:

- [ ] All tests passing
- [ ] Security audit completed
- [ ] Performance benchmarks met
- [ ] Documentation up to date
- [ ] Error handling comprehensive
- [ ] Logging configured
- [ ] Database backed up
- [ ] Rate limits configured
- [ ] CORS configured properly
- [ ] Environment variables set
- [ ] Health checks working
- [ ] Monitoring in place

---

## üéâ You're Ready!

This implementation provides:
- ‚úÖ Type-safe API with full autocomplete
- ‚úÖ Production-ready security
- ‚úÖ Comprehensive error handling
- ‚úÖ Scalable architecture
- ‚úÖ Easy to test and maintain

**Next Steps:**
1. Start with Phase 1 (Foundation)
2. Test each component thoroughly
3. Integrate with your frontend
4. Deploy and monitor

Good luck! üöÄ

// ==========================================
// ENTITY FRAMEWORK PATTERN - TypeScript/Node.js
// Similar to C# Entity Framework
// ==========================================

// ==========================================
// 1. BASE ENTITY & REPOSITORY PATTERN
// ==========================================
// File: apps/workbench-desktop/src/api/entities/base/BaseEntity.ts

export abstract class BaseEntity {
  id: string;
  createdAt: number;
  updatedAt: number;

  constructor(data?: Partial<BaseEntity>) {
    this.id = data?.id || crypto.randomUUID();
    this.createdAt = data?.createdAt || Date.now();
    this.updatedAt = data?.updatedAt || Date.now();
  }

  // Mark entity as modified
  markModified(): void {
    this.updatedAt = Date.now();
  }

  // Validation hook - override in derived classes
  validate(): void {
    if (!this.id) throw new Error('Entity ID is required');
  }

  // Convert to plain object for database
  abstract toDatabase(): Record<string, any>;

  // Create entity from database row
  static fromDatabase<T extends BaseEntity>(this: new (data: any) => T, data: any): T {
    return new this(data);
  }
}

// ==========================================
// 2. BASE REPOSITORY (Generic CRUD)
// ==========================================
// File: apps/workbench-desktop/src/api/entities/base/BaseRepository.ts

import { Database } from 'better-sqlite3';

export interface IRepository<T extends BaseEntity> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(entity: T): Promise<T>;
  update(entity: T): Promise<T>;
  delete(id: string): Promise<boolean>;
  exists(id: string): Promise<boolean>;
}

export abstract class BaseRepository<T extends BaseEntity> implements IRepository<T> {
  protected db: Database.Database;
  protected tableName: string;
  protected entityClass: new (data: any) => T;

  constructor(db: Database.Database, tableName: string, entityClass: new (data: any) => T) {
    this.db = db;
    this.tableName = tableName;
    this.entityClass = entityClass;
  }

  // Abstract method to map database row to entity
  protected abstract mapRowToEntity(row: any): T;

  // Abstract method to map entity to database columns
  protected abstract mapEntityToRow(entity: T): Record<string, any>;

  async findById(id: string): Promise<T | null> {
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`);
    const row = stmt.get(id);
    
    if (!row) return null;
    return this.mapRowToEntity(row);
  }

  async findAll(): Promise<T[]> {
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName}`);
    const rows = stmt.all();
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  async findWhere(conditions: Record<string, any>): Promise<T[]> {
    const keys = Object.keys(conditions);
    const whereClause = keys.map(key => `${key} = ?`).join(' AND ');
    const values = keys.map(key => conditions[key]);
    
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE ${whereClause}`);
    const rows = stmt.all(...values);
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  async create(entity: T): Promise<T> {
    entity.validate();
    
    const data = this.mapEntityToRow(entity);
    const columns = Object.keys(data);
    const placeholders = columns.map(() => '?').join(', ');
    const values = columns.map(col => data[col]);
    
    const stmt = this.db.prepare(
      `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`
    );
    
    stmt.run(...values);
    
    return entity;
  }

  async update(entity: T): Promise<T> {
    entity.validate();
    entity.markModified();
    
    const data = this.mapEntityToRow(entity);
    const columns = Object.keys(data).filter(col => col !== 'id');
    const setClause = columns.map(col => `${col} = ?`).join(', ');
    const values = [...columns.map(col => data[col]), entity.id];
    
    const stmt = this.db.prepare(
      `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`
    );
    
    const result = stmt.run(...values);
    
    if (result.changes === 0) {
      throw new Error(`Entity with ID ${entity.id} not found`);
    }
    
    return entity;
  }

  async delete(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`DELETE FROM ${this.tableName} WHERE id = ?`);
    const result = stmt.run(id);
    
    return result.changes > 0;
  }

  async exists(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`SELECT COUNT(*) as count FROM ${this.tableName} WHERE id = ?`);
    const result = stmt.get(id) as { count: number };
    
    return result.count > 0;
  }

  async count(): Promise<number> {
    const stmt = this.db.prepare(`SELECT COUNT(*) as count FROM ${this.tableName}`);
    const result = stmt.get() as { count: number };
    
    return result.count;
  }

  // Transaction support
  transaction<R>(callback: () => R): R {
    const transaction = this.db.transaction(callback);
    return transaction();
  }
}

// ==========================================
// 3. PROVIDER ENTITY & REPOSITORY
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Provider.entity.ts

import { BaseEntity } from './base/BaseEntity';
import { z } from 'zod';

export enum ProviderType {
  LOCAL = 'local',
  CLOUD = 'cloud',
  OPENAI = 'openai',
  ANTHROPIC = 'anthropic',
}

export interface ModelInfo {
  id: string;
  name: string;
  contextWindow?: number;
  maxTokens?: number;
}

export class ProviderEntity extends BaseEntity {
  name: string;
  type: ProviderType;
  endpoint?: string;
  apiKey?: string;
  models: ModelInfo[];
  metadata: Record<string, any>;

  constructor(data: Partial<ProviderEntity>) {
    super(data);
    this.name = data.name || '';
    this.type = data.type || ProviderType.LOCAL;
    this.endpoint = data.endpoint;
    this.apiKey = data.apiKey;
    this.models = data.models || [];
    this.metadata = data.metadata || {};
  }

  validate(): void {
    super.validate();
    
    if (!this.name || this.name.length === 0) {
      throw new Error('Provider name is required');
    }
    
    if (this.name.length > 100) {
      throw new Error('Provider name must be less than 100 characters');
    }
    
    if (!Object.values(ProviderType).includes(this.type)) {
      throw new Error('Invalid provider type');
    }
    
    if (this.models.length === 0) {
      throw new Error('At least one model is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      endpoint: this.endpoint || null,
      api_key: this.apiKey || null,
      models: JSON.stringify(this.models),
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  // Business logic methods
  addModel(model: ModelInfo): void {
    if (this.models.some(m => m.id === model.id)) {
      throw new Error('Model with this ID already exists');
    }
    this.models.push(model);
    this.markModified();
  }

  removeModel(modelId: string): void {
    const index = this.models.findIndex(m => m.id === modelId);
    if (index === -1) {
      throw new Error('Model not found');
    }
    this.models.splice(index, 1);
    this.markModified();
  }

  async testConnection(): Promise<boolean> {
    // Implement connection test logic
    return true;
  }
}

// File: apps/workbench-desktop/src/api/entities/Provider.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { ProviderEntity, ProviderType } from './Provider.entity';
import { Database } from 'better-sqlite3';

export class ProviderRepository extends BaseRepository<ProviderEntity> {
  constructor(db: Database.Database) {
    super(db, 'providers', ProviderEntity);
  }

  protected mapRowToEntity(row: any): ProviderEntity {
    return new ProviderEntity({
      id: row.id,
      name: row.name,
      type: row.type as ProviderType,
      endpoint: row.endpoint,
      apiKey: row.api_key,
      models: JSON.parse(row.models),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: ProviderEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Custom query methods
  async findByType(type: ProviderType): Promise<ProviderEntity[]> {
    return this.findWhere({ type });
  }

  async findByName(name: string): Promise<ProviderEntity | null> {
    const results = await this.findWhere({ name });
    return results[0] || null;
  }

  async hasActiveAgents(providerId: string): Promise<boolean> {
    const stmt = this.db.prepare(
      `SELECT COUNT(*) as count FROM agents WHERE model_id = ?`
    );
    const result = stmt.get(providerId) as { count: number };
    return result.count > 0;
  }
}

// ==========================================
// 4. AGENT ENTITY & REPOSITORY
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Agent.entity.ts

import { BaseEntity } from './base/BaseEntity';

export enum AgentRole {
  PLANNER = 'planner',
  CODER = 'coder',
  REVIEWER = 'reviewer',
  TESTER = 'tester',
  RESEARCHER = 'researcher',
  COORDINATOR = 'coordinator',
}

export class AgentEntity extends BaseEntity {
  name: string;
  role: AgentRole;
  modelId: string;
  systemPrompt: string;
  temperature: number;
  maxTokens?: number;
  tools: string[];
  metadata: Record<string, any>;
  isActive: boolean;

  constructor(data: Partial<AgentEntity>) {
    super(data);
    this.name = data.name || '';
    this.role = data.role || AgentRole.CODER;
    this.modelId = data.modelId || '';
    this.systemPrompt = data.systemPrompt || '';
    this.temperature = data.temperature ?? 0.7;
    this.maxTokens = data.maxTokens;
    this.tools = data.tools || [];
    this.metadata = data.metadata || {};
    this.isActive = data.isActive ?? true;
  }

  validate(): void {
    super.validate();
    
    if (!this.name || this.name.length === 0) {
      throw new Error('Agent name is required');
    }
    
    if (!this.modelId) {
      throw new Error('Model ID is required');
    }
    
    if (!this.systemPrompt || this.systemPrompt.length < 10) {
      throw new Error('System prompt must be at least 10 characters');
    }
    
    if (this.temperature < 0 || this.temperature > 2) {
      throw new Error('Temperature must be between 0 and 2');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      role: this.role,
      model_id: this.modelId,
      system_prompt: this.systemPrompt,
      temperature: this.temperature,
      max_tokens: this.maxTokens || null,
      tools: JSON.stringify(this.tools),
      metadata: JSON.stringify(this.metadata),
      is_active: this.isActive ? 1 : 0,
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  // Business logic
  activate(): void {
    this.isActive = true;
    this.markModified();
  }

  deactivate(): void {
    this.isActive = false;
    this.markModified();
  }

  toggleActive(): void {
    this.isActive = !this.isActive;
    this.markModified();
  }

  addTool(toolName: string): void {
    if (!this.tools.includes(toolName)) {
      this.tools.push(toolName);
      this.markModified();
    }
  }

  removeTool(toolName: string): void {
    const index = this.tools.indexOf(toolName);
    if (index > -1) {
      this.tools.splice(index, 1);
      this.markModified();
    }
  }
}

// File: apps/workbench-desktop/src/api/entities/Agent.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { AgentEntity, AgentRole } from './Agent.entity';
import { Database } from 'better-sqlite3';

export class AgentRepository extends BaseRepository<AgentEntity> {
  constructor(db: Database.Database) {
    super(db, 'agents', AgentEntity);
  }

  protected mapRowToEntity(row: any): AgentEntity {
    return new AgentEntity({
      id: row.id,
      name: row.name,
      role: row.role as AgentRole,
      modelId: row.model_id,
      systemPrompt: row.system_prompt,
      temperature: row.temperature,
      maxTokens: row.max_tokens,
      tools: JSON.parse(row.tools || '[]'),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      isActive: Boolean(row.is_active),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: AgentEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Custom queries
  async findByRole(role: AgentRole): Promise<AgentEntity[]> {
    return this.findWhere({ role });
  }

  async findActive(): Promise<AgentEntity[]> {
    return this.findWhere({ is_active: 1 });
  }

  async findByModelId(modelId: string): Promise<AgentEntity[]> {
    return this.findWhere({ model_id: modelId });
  }

  // With relations
  async findWithProvider(agentId: string): Promise<{ agent: AgentEntity; provider: any } | null> {
    const stmt = this.db.prepare(`
      SELECT a.*, p.name as provider_name, p.type as provider_type
      FROM agents a
      JOIN providers p ON a.model_id = p.id
      WHERE a.id = ?
    `);
    
    const row = stmt.get(agentId);
    if (!row) return null;
    
    return {
      agent: this.mapRowToEntity(row),
      provider: {
        name: row.provider_name,
        type: row.provider_type,
      },
    };
  }
}

// ==========================================
// 5. MESSAGE & CONVERSATION ENTITIES
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Conversation.entity.ts

import { BaseEntity } from './base/BaseEntity';

export class ConversationEntity extends BaseEntity {
  title: string;
  agentIds: string[];
  metadata: Record<string, any>;

  constructor(data: Partial<ConversationEntity>) {
    super(data);
    this.title = data.title || 'New Conversation';
    this.agentIds = data.agentIds || [];
    this.metadata = data.metadata || {};
  }

  validate(): void {
    super.validate();
    
    if (!this.title || this.title.length === 0) {
      throw new Error('Conversation title is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      title: this.title,
      agent_ids: JSON.stringify(this.agentIds),
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  addAgent(agentId: string): void {
    if (!this.agentIds.includes(agentId)) {
      this.agentIds.push(agentId);
      this.markModified();
    }
  }

  removeAgent(agentId: string): void {
    const index = this.agentIds.indexOf(agentId);
    if (index > -1) {
      this.agentIds.splice(index, 1);
      this.markModified();
    }
  }
}

// File: apps/workbench-desktop/src/api/entities/Message.entity.ts

import { BaseEntity } from './base/BaseEntity';

export enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system',
  TOOL = 'tool',
}

export class MessageEntity extends BaseEntity {
  conversationId: string;
  role: MessageRole;
  content: string;
  name?: string;
  toolCallId?: string;
  parentMessageId?: string;
  tokens?: number;
  timestamp: number;

  constructor(data: Partial<MessageEntity>) {
    super(data);
    this.conversationId = data.conversationId || '';
    this.role = data.role || MessageRole.USER;
    this.content = data.content || '';
    this.name = data.name;
    this.toolCallId = data.toolCallId;
    this.parentMessageId = data.parentMessageId;
    this.tokens = data.tokens;
    this.timestamp = data.timestamp || Date.now();
  }

  validate(): void {
    super.validate();
    
    if (!this.conversationId) {
      throw new Error('Conversation ID is required');
    }
    
    if (!this.content || this.content.length === 0) {
      throw new Error('Message content is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      conversation_id: this.conversationId,
      role: this.role,
      content: this.content,
      name: this.name || null,
      tool_call_id: this.toolCallId || null,
      parent_message_id: this.parentMessageId || null,
      tokens: this.tokens || null,
      timestamp: this.timestamp,
    };
  }

  isFromUser(): boolean {
    return this.role === MessageRole.USER;
  }

  isFromAssistant(): boolean {
    return this.role === MessageRole.ASSISTANT;
  }
}

// File: apps/workbench-desktop/src/api/entities/Conversation.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { ConversationEntity } from './Conversation.entity';
import { MessageEntity, MessageRole } from './Message.entity';
import { Database } from 'better-sqlite3';

export class ConversationRepository extends BaseRepository<ConversationEntity> {
  constructor(db: Database.Database) {
    super(db, 'conversations', ConversationEntity);
  }

  protected mapRowToEntity(row: any): ConversationEntity {
    return new ConversationEntity({
      id: row.id,
      title: row.title,
      agentIds: JSON.parse(row.agent_ids || '[]'),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: ConversationEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Get conversation with all messages
  async findWithMessages(conversationId: string): Promise<{
    conversation: ConversationEntity;
    messages: MessageEntity[];
  } | null> {
    const conversation = await this.findById(conversationId);
    if (!conversation) return null;
    
    const messageRepo = new MessageRepository(this.db);
    const messages = await messageRepo.findByConversation(conversationId);
    
    return { conversation, messages };
  }

  // Get recent conversations with message counts
  async findRecent(limit: number = 50): Promise<Array<ConversationEntity & { messageCount: number }>> {
    const stmt = this.db.prepare(`
      SELECT c.*, COUNT(m.id) as message_count
      FROM conversations c
      LEFT JOIN messages m ON c.id = m.conversation_id
      GROUP BY c.id
      ORDER BY c.updated_at DESC
      LIMIT ?
    `);
    
    const rows = stmt.all(limit);
    
    return rows.map(row => ({
      ...this.mapRowToEntity(row),
      messageCount: row.message_count,
    }));
  }
}

// File: apps/workbench-desktop/src/api/entities/Message.repository.ts

export class MessageRepository extends BaseRepository<MessageEntity> {
  constructor(db: Database.Database) {
    super(db, 'messages', MessageEntity);
  }

  protected mapRowToEntity(row: any): MessageEntity {
    return new MessageEntity({
      id: row.id,
      conversationId: row.conversation_id,
      role: row.role as MessageRole,
      content: row.content,
      name: row.name,
      toolCallId: row.tool_call_id,
      parentMessageId: row.parent_message_id,
      tokens: row.tokens,
      timestamp: row.timestamp,
    });
  }

  protected mapEntityToRow(entity: MessageEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Find messages by conversation
  async findByConversation(
    conversationId: string,
    options?: { limit?: number; offset?: number; beforeTimestamp?: number }
  ): Promise<MessageEntity[]> {
    let query = 'SELECT * FROM messages WHERE conversation_id = ?';
    const params: any[] = [conversationId];
    
    if (options?.beforeTimestamp) {
      query += ' AND timestamp < ?';
      params.push(options.beforeTimestamp);
    }
    
    query += ' ORDER BY timestamp ASC';
    
    if (options?.limit) {
      query += ' LIMIT ?';
      params.push(options.limit);
      
      if (options?.offset) {
        query += ' OFFSET ?';
        params.push(options.offset);
      }
    }
    
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Search messages
  async search(searchQuery: string, limit: number = 20): Promise<MessageEntity[]> {
    const stmt = this.db.prepare(`
      SELECT m.*
      FROM messages_fts
      JOIN messages m ON messages_fts.rowid = m.rowid
      WHERE messages_fts MATCH ?
      ORDER BY rank
      LIMIT ?
    `);
    
    const rows = stmt.all(searchQuery, limit);
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Delete all messages in conversation
  async deleteByConversation(conversationId: string): Promise<number> {
    const stmt = this.db.prepare('DELETE FROM messages WHERE conversation_id = ?');
    const result = stmt.run(conversationId);
    return result.changes;
  }
}

// ==========================================
// 6. DB CONTEXT (Entity Framework DbContext equivalent)
// ==========================================
// File: apps/workbench-desktop/src/api/entities/DbContext.ts

import Database from 'better-sqlite3';
import { ProviderRepository } from './Provider.repository';
import { AgentRepository } from './Agent.repository';
import { ConversationRepository } from './Conversation.repository';
import { MessageRepository } from './Message.repository';

export class DbContext {
  private static instance: DbContext;
  private db: Database.Database;

  // Repositories (like DbSets in EF)
  public providers: ProviderRepository;
  public agents: AgentRepository;
  public conversations: ConversationRepository;
  public messages: MessageRepository;

  private constructor(dbPath: string = 'workbench.db') {
    this.db = new Database(dbPath);
    this.db.pragma('foreign_keys = ON');
    
    // Initialize repositories
    this.providers = new ProviderRepository(this.db);
    this.agents = new AgentRepository(this.db);
    this.conversations = new ConversationRepository(this.db);
    this.messages = new MessageRepository(this.db);
  }

  static getInstance(dbPath?: string): DbContext {
    if (!DbContext.instance) {
      DbContext.instance = new DbContext(dbPath);
    }
    return DbContext.instance;
  }

  // Transaction support (like EF's SaveChanges)
  transaction<T>(callback: () => T): T {
    const transaction = this.db.transaction(callback);
    return transaction();
  }

  // Async transaction
  async transactionAsync<T>(callback: () => Promise<T>): Promise<T> {
    this.db.prepare('BEGIN').run();
    try {
      const result = await callback();
      this.db.prepare('COMMIT').run();
      return result;
    } catch (error) {
      this.db.prepare('ROLLBACK').run();
      throw error;
    }
  }

  // Close database connection
  close(): void {
    this.db.close();
  }
}

// ==========================================
// 7. USAGE IN tRPC ROUTERS
// ==========================================
// File: apps/workbench-desktop/src/api/routers/provider.router.v2.ts

import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import { createProviderSchema, updateProviderSchema } from '../schemas/provider.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { ProviderEntity, ProviderType } from '../entities/Provider.entity';

export const providerRouter = router({
  /**
   * List all providers using Entity Framework pattern
   */
  list: publicProcedure.query(async ({ ctx }) => {
    const providers = await ctx.dbContext.providers.findAll();
    return providers;
  }),

  /**
   * Get provider by ID
   */
  getById: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const provider = await ctx.dbContext.providers.findById(input.id);
      
      if (!provider) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      return provider;
    }),

  /**
   * Create new provider using Entity
   */
  create: protectedProcedure
    .input(createProviderSchema)
    .mutation(async ({ ctx, input }) => {
      // Create entity instance
      const provider = new ProviderEntity({
        name: input.name,
        type: input.type as ProviderType,
        endpoint: input.endpoint,
        apiKey: input.apiKey,
        models: input.models,
        metadata: input.metadata || {},
      });
      
      // Validate entity
      provider.validate();
      
      // Save to database
      const saved = await ctx.dbContext.providers.create(provider);
      
      return saved;
    }),

  /**
   * Update provider using Entity
   */
  update: protectedProcedure
    .input(updateProviderSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;
      
      // Load existing entity
      const provider = await ctx.dbContext.providers.findById(id);
      
      if (!provider) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${id} not found`,
        });
      }
      
      // Update entity properties
      if (updates.name) provider.name = updates.name;
      if (updates.type) provider.type = updates.type as ProviderType;
      if (updates.endpoint !== undefined) provider.endpoint = updates.endpoint;
      if (updates.apiKey !== undefined) provider.apiKey = updates.apiKey;
      if (updates.models) provider.models = updates.models;
      if (updates.metadata) provider.metadata = updates.metadata;
      
      // Save changes
      const updated = await ctx.dbContext.providers.update(provider);
      
      return updated;
    }),

  /**
   * Delete provider with business logic
   */
  delete: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // Check if any agents are using this provider
      const hasAgents = await ctx.dbContext.providers.hasActiveAgents(input.id);
      
      if (hasAgents) {
        throw new TRPCError({
          code: 'PRECONDITION_FAILED',
          message: 'Cannot delete provider: agents are using it',
        });
      }
      
      const deleted = await ctx.dbContext.providers.delete(input.id);
      
      if (!deleted) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      return { success: true, deletedId: input.id };
    }),

  /**
   * Add model to provider using entity method
   */
  addModel: protectedProcedure
    .input(z.object({
      providerId: z.string().uuid(),
      model: z.object({
        id: z.string(),
        name: z.string(),
        contextWindow: z.number().optional(),
        maxTokens: z.number().optional(),
      }),
    }))
    .mutation(async ({ ctx, input }) => {
      const provider = await ctx



// ==========================================
// ENTITY FRAMEWORK PATTERN - TypeScript/Node.js
// Similar to C# Entity Framework
// ==========================================

// ==========================================
// 1. BASE ENTITY & REPOSITORY PATTERN
// ==========================================
// File: apps/workbench-desktop/src/api/entities/base/BaseEntity.ts

export abstract class BaseEntity {
  id: string;
  createdAt: number;
  updatedAt: number;

  constructor(data?: Partial<BaseEntity>) {
    this.id = data?.id || crypto.randomUUID();
    this.createdAt = data?.createdAt || Date.now();
    this.updatedAt = data?.updatedAt || Date.now();
  }

  // Mark entity as modified
  markModified(): void {
    this.updatedAt = Date.now();
  }

  // Validation hook - override in derived classes
  validate(): void {
    if (!this.id) throw new Error('Entity ID is required');
  }

  // Convert to plain object for database
  abstract toDatabase(): Record<string, any>;

  // Create entity from database row
  static fromDatabase<T extends BaseEntity>(this: new (data: any) => T, data: any): T {
    return new this(data);
  }
}

// ==========================================
// 2. BASE REPOSITORY (Generic CRUD)
// ==========================================
// File: apps/workbench-desktop/src/api/entities/base/BaseRepository.ts

import { Database } from 'better-sqlite3';

export interface IRepository<T extends BaseEntity> {
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(entity: T): Promise<T>;
  update(entity: T): Promise<T>;
  delete(id: string): Promise<boolean>;
  exists(id: string): Promise<boolean>;
}

export abstract class BaseRepository<T extends BaseEntity> implements IRepository<T> {
  protected db: Database.Database;
  protected tableName: string;
  protected entityClass: new (data: any) => T;

  constructor(db: Database.Database, tableName: string, entityClass: new (data: any) => T) {
    this.db = db;
    this.tableName = tableName;
    this.entityClass = entityClass;
  }

  // Abstract method to map database row to entity
  protected abstract mapRowToEntity(row: any): T;

  // Abstract method to map entity to database columns
  protected abstract mapEntityToRow(entity: T): Record<string, any>;

  async findById(id: string): Promise<T | null> {
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE id = ?`);
    const row = stmt.get(id);
    
    if (!row) return null;
    return this.mapRowToEntity(row);
  }

  async findAll(): Promise<T[]> {
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName}`);
    const rows = stmt.all();
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  async findWhere(conditions: Record<string, any>): Promise<T[]> {
    const keys = Object.keys(conditions);
    const whereClause = keys.map(key => `${key} = ?`).join(' AND ');
    const values = keys.map(key => conditions[key]);
    
    const stmt = this.db.prepare(`SELECT * FROM ${this.tableName} WHERE ${whereClause}`);
    const rows = stmt.all(...values);
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  async create(entity: T): Promise<T> {
    entity.validate();
    
    const data = this.mapEntityToRow(entity);
    const columns = Object.keys(data);
    const placeholders = columns.map(() => '?').join(', ');
    const values = columns.map(col => data[col]);
    
    const stmt = this.db.prepare(
      `INSERT INTO ${this.tableName} (${columns.join(', ')}) VALUES (${placeholders})`
    );
    
    stmt.run(...values);
    
    return entity;
  }

  async update(entity: T): Promise<T> {
    entity.validate();
    entity.markModified();
    
    const data = this.mapEntityToRow(entity);
    const columns = Object.keys(data).filter(col => col !== 'id');
    const setClause = columns.map(col => `${col} = ?`).join(', ');
    const values = [...columns.map(col => data[col]), entity.id];
    
    const stmt = this.db.prepare(
      `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`
    );
    
    const result = stmt.run(...values);
    
    if (result.changes === 0) {
      throw new Error(`Entity with ID ${entity.id} not found`);
    }
    
    return entity;
  }

  async delete(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`DELETE FROM ${this.tableName} WHERE id = ?`);
    const result = stmt.run(id);
    
    return result.changes > 0;
  }

  async exists(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`SELECT COUNT(*) as count FROM ${this.tableName} WHERE id = ?`);
    const result = stmt.get(id) as { count: number };
    
    return result.count > 0;
  }

  async count(): Promise<number> {
    const stmt = this.db.prepare(`SELECT COUNT(*) as count FROM ${this.tableName}`);
    const result = stmt.get() as { count: number };
    
    return result.count;
  }

  // Transaction support
  transaction<R>(callback: () => R): R {
    const transaction = this.db.transaction(callback);
    return transaction();
  }
}

// ==========================================
// 3. PROVIDER ENTITY & REPOSITORY
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Provider.entity.ts

import { BaseEntity } from './base/BaseEntity';
import { z } from 'zod';

export enum ProviderType {
  LOCAL = 'local',
  CLOUD = 'cloud',
  OPENAI = 'openai',
  ANTHROPIC = 'anthropic',
}

export interface ModelInfo {
  id: string;
  name: string;
  contextWindow?: number;
  maxTokens?: number;
}

export class ProviderEntity extends BaseEntity {
  name: string;
  type: ProviderType;
  endpoint?: string;
  apiKey?: string;
  models: ModelInfo[];
  metadata: Record<string, any>;

  constructor(data: Partial<ProviderEntity>) {
    super(data);
    this.name = data.name || '';
    this.type = data.type || ProviderType.LOCAL;
    this.endpoint = data.endpoint;
    this.apiKey = data.apiKey;
    this.models = data.models || [];
    this.metadata = data.metadata || {};
  }

  validate(): void {
    super.validate();
    
    if (!this.name || this.name.length === 0) {
      throw new Error('Provider name is required');
    }
    
    if (this.name.length > 100) {
      throw new Error('Provider name must be less than 100 characters');
    }
    
    if (!Object.values(ProviderType).includes(this.type)) {
      throw new Error('Invalid provider type');
    }
    
    if (this.models.length === 0) {
      throw new Error('At least one model is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      endpoint: this.endpoint || null,
      api_key: this.apiKey || null,
      models: JSON.stringify(this.models),
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  // Business logic methods
  addModel(model: ModelInfo): void {
    if (this.models.some(m => m.id === model.id)) {
      throw new Error('Model with this ID already exists');
    }
    this.models.push(model);
    this.markModified();
  }

  removeModel(modelId: string): void {
    const index = this.models.findIndex(m => m.id === modelId);
    if (index === -1) {
      throw new Error('Model not found');
    }
    this.models.splice(index, 1);
    this.markModified();
  }

  async testConnection(): Promise<boolean> {
    // Implement connection test logic
    return true;
  }
}

// File: apps/workbench-desktop/src/api/entities/Provider.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { ProviderEntity, ProviderType } from './Provider.entity';
import { Database } from 'better-sqlite3';

export class ProviderRepository extends BaseRepository<ProviderEntity> {
  constructor(db: Database.Database) {
    super(db, 'providers', ProviderEntity);
  }

  protected mapRowToEntity(row: any): ProviderEntity {
    return new ProviderEntity({
      id: row.id,
      name: row.name,
      type: row.type as ProviderType,
      endpoint: row.endpoint,
      apiKey: row.api_key,
      models: JSON.parse(row.models),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: ProviderEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Custom query methods
  async findByType(type: ProviderType): Promise<ProviderEntity[]> {
    return this.findWhere({ type });
  }

  async findByName(name: string): Promise<ProviderEntity | null> {
    const results = await this.findWhere({ name });
    return results[0] || null;
  }

  async hasActiveAgents(providerId: string): Promise<boolean> {
    const stmt = this.db.prepare(
      `SELECT COUNT(*) as count FROM agents WHERE model_id = ?`
    );
    const result = stmt.get(providerId) as { count: number };
    return result.count > 0;
  }
}

// ==========================================
// 4. AGENT ENTITY & REPOSITORY
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Agent.entity.ts

import { BaseEntity } from './base/BaseEntity';

export enum AgentRole {
  PLANNER = 'planner',
  CODER = 'coder',
  REVIEWER = 'reviewer',
  TESTER = 'tester',
  RESEARCHER = 'researcher',
  COORDINATOR = 'coordinator',
}

export class AgentEntity extends BaseEntity {
  name: string;
  role: AgentRole;
  modelId: string;
  systemPrompt: string;
  temperature: number;
  maxTokens?: number;
  tools: string[];
  metadata: Record<string, any>;
  isActive: boolean;

  constructor(data: Partial<AgentEntity>) {
    super(data);
    this.name = data.name || '';
    this.role = data.role || AgentRole.CODER;
    this.modelId = data.modelId || '';
    this.systemPrompt = data.systemPrompt || '';
    this.temperature = data.temperature ?? 0.7;
    this.maxTokens = data.maxTokens;
    this.tools = data.tools || [];
    this.metadata = data.metadata || {};
    this.isActive = data.isActive ?? true;
  }

  validate(): void {
    super.validate();
    
    if (!this.name || this.name.length === 0) {
      throw new Error('Agent name is required');
    }
    
    if (!this.modelId) {
      throw new Error('Model ID is required');
    }
    
    if (!this.systemPrompt || this.systemPrompt.length < 10) {
      throw new Error('System prompt must be at least 10 characters');
    }
    
    if (this.temperature < 0 || this.temperature > 2) {
      throw new Error('Temperature must be between 0 and 2');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      role: this.role,
      model_id: this.modelId,
      system_prompt: this.systemPrompt,
      temperature: this.temperature,
      max_tokens: this.maxTokens || null,
      tools: JSON.stringify(this.tools),
      metadata: JSON.stringify(this.metadata),
      is_active: this.isActive ? 1 : 0,
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  // Business logic
  activate(): void {
    this.isActive = true;
    this.markModified();
  }

  deactivate(): void {
    this.isActive = false;
    this.markModified();
  }

  toggleActive(): void {
    this.isActive = !this.isActive;
    this.markModified();
  }

  addTool(toolName: string): void {
    if (!this.tools.includes(toolName)) {
      this.tools.push(toolName);
      this.markModified();
    }
  }

  removeTool(toolName: string): void {
    const index = this.tools.indexOf(toolName);
    if (index > -1) {
      this.tools.splice(index, 1);
      this.markModified();
    }
  }
}

// File: apps/workbench-desktop/src/api/entities/Agent.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { AgentEntity, AgentRole } from './Agent.entity';
import { Database } from 'better-sqlite3';

export class AgentRepository extends BaseRepository<AgentEntity> {
  constructor(db: Database.Database) {
    super(db, 'agents', AgentEntity);
  }

  protected mapRowToEntity(row: any): AgentEntity {
    return new AgentEntity({
      id: row.id,
      name: row.name,
      role: row.role as AgentRole,
      modelId: row.model_id,
      systemPrompt: row.system_prompt,
      temperature: row.temperature,
      maxTokens: row.max_tokens,
      tools: JSON.parse(row.tools || '[]'),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      isActive: Boolean(row.is_active),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: AgentEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Custom queries
  async findByRole(role: AgentRole): Promise<AgentEntity[]> {
    return this.findWhere({ role });
  }

  async findActive(): Promise<AgentEntity[]> {
    return this.findWhere({ is_active: 1 });
  }

  async findByModelId(modelId: string): Promise<AgentEntity[]> {
    return this.findWhere({ model_id: modelId });
  }

  // With relations
  async findWithProvider(agentId: string): Promise<{ agent: AgentEntity; provider: any } | null> {
    const stmt = this.db.prepare(`
      SELECT a.*, p.name as provider_name, p.type as provider_type
      FROM agents a
      JOIN providers p ON a.model_id = p.id
      WHERE a.id = ?
    `);
    
    const row = stmt.get(agentId);
    if (!row) return null;
    
    return {
      agent: this.mapRowToEntity(row),
      provider: {
        name: row.provider_name,
        type: row.provider_type,
      },
    };
  }
}

// ==========================================
// 5. MESSAGE & CONVERSATION ENTITIES
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Conversation.entity.ts

import { BaseEntity } from './base/BaseEntity';

export class ConversationEntity extends BaseEntity {
  title: string;
  agentIds: string[];
  metadata: Record<string, any>;

  constructor(data: Partial<ConversationEntity>) {
    super(data);
    this.title = data.title || 'New Conversation';
    this.agentIds = data.agentIds || [];
    this.metadata = data.metadata || {};
  }

  validate(): void {
    super.validate();
    
    if (!this.title || this.title.length === 0) {
      throw new Error('Conversation title is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      title: this.title,
      agent_ids: JSON.stringify(this.agentIds),
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  addAgent(agentId: string): void {
    if (!this.agentIds.includes(agentId)) {
      this.agentIds.push(agentId);
      this.markModified();
    }
  }

  removeAgent(agentId: string): void {
    const index = this.agentIds.indexOf(agentId);
    if (index > -1) {
      this.agentIds.splice(index, 1);
      this.markModified();
    }
  }
}

// File: apps/workbench-desktop/src/api/entities/Message.entity.ts

import { BaseEntity } from './base/BaseEntity';

export enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system',
  TOOL = 'tool',
}

export class MessageEntity extends BaseEntity {
  conversationId: string;
  role: MessageRole;
  content: string;
  name?: string;
  toolCallId?: string;
  parentMessageId?: string;
  tokens?: number;
  timestamp: number;

  constructor(data: Partial<MessageEntity>) {
    super(data);
    this.conversationId = data.conversationId || '';
    this.role = data.role || MessageRole.USER;
    this.content = data.content || '';
    this.name = data.name;
    this.toolCallId = data.toolCallId;
    this.parentMessageId = data.parentMessageId;
    this.tokens = data.tokens;
    this.timestamp = data.timestamp || Date.now();
  }

  validate(): void {
    super.validate();
    
    if (!this.conversationId) {
      throw new Error('Conversation ID is required');
    }
    
    if (!this.content || this.content.length === 0) {
      throw new Error('Message content is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      conversation_id: this.conversationId,
      role: this.role,
      content: this.content,
      name: this.name || null,
      tool_call_id: this.toolCallId || null,
      parent_message_id: this.parentMessageId || null,
      tokens: this.tokens || null,
      timestamp: this.timestamp,
    };
  }

  isFromUser(): boolean {
    return this.role === MessageRole.USER;
  }

  isFromAssistant(): boolean {
    return this.role === MessageRole.ASSISTANT;
  }
}

// File: apps/workbench-desktop/src/api/entities/Conversation.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { ConversationEntity } from './Conversation.entity';
import { MessageEntity, MessageRole } from './Message.entity';
import { Database } from 'better-sqlite3';

export class ConversationRepository extends BaseRepository<ConversationEntity> {
  constructor(db: Database.Database) {
    super(db, 'conversations', ConversationEntity);
  }

  protected mapRowToEntity(row: any): ConversationEntity {
    return new ConversationEntity({
      id: row.id,
      title: row.title,
      agentIds: JSON.parse(row.agent_ids || '[]'),
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: ConversationEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Get conversation with all messages
  async findWithMessages(conversationId: string): Promise<{
    conversation: ConversationEntity;
    messages: MessageEntity[];
  } | null> {
    const conversation = await this.findById(conversationId);
    if (!conversation) return null;
    
    const messageRepo = new MessageRepository(this.db);
    const messages = await messageRepo.findByConversation(conversationId);
    
    return { conversation, messages };
  }

  // Get recent conversations with message counts
  async findRecent(limit: number = 50): Promise<Array<ConversationEntity & { messageCount: number }>> {
    const stmt = this.db.prepare(`
      SELECT c.*, COUNT(m.id) as message_count
      FROM conversations c
      LEFT JOIN messages m ON c.id = m.conversation_id
      GROUP BY c.id
      ORDER BY c.updated_at DESC
      LIMIT ?
    `);
    
    const rows = stmt.all(limit);
    
    return rows.map(row => ({
      ...this.mapRowToEntity(row),
      messageCount: row.message_count,
    }));
  }
}

// File: apps/workbench-desktop/src/api/entities/Message.repository.ts

export class MessageRepository extends BaseRepository<MessageEntity> {
  constructor(db: Database.Database) {
    super(db, 'messages', MessageEntity);
  }

  protected mapRowToEntity(row: any): MessageEntity {
    return new MessageEntity({
      id: row.id,
      conversationId: row.conversation_id,
      role: row.role as MessageRole,
      content: row.content,
      name: row.name,
      toolCallId: row.tool_call_id,
      parentMessageId: row.parent_message_id,
      tokens: row.tokens,
      timestamp: row.timestamp,
    });
  }

  protected mapEntityToRow(entity: MessageEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Find messages by conversation
  async findByConversation(
    conversationId: string,
    options?: { limit?: number; offset?: number; beforeTimestamp?: number }
  ): Promise<MessageEntity[]> {
    let query = 'SELECT * FROM messages WHERE conversation_id = ?';
    const params: any[] = [conversationId];
    
    if (options?.beforeTimestamp) {
      query += ' AND timestamp < ?';
      params.push(options.beforeTimestamp);
    }
    
    query += ' ORDER BY timestamp ASC';
    
    if (options?.limit) {
      query += ' LIMIT ?';
      params.push(options.limit);
      
      if (options?.offset) {
        query += ' OFFSET ?';
        params.push(options.offset);
      }
    }
    
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Search messages
  async search(searchQuery: string, limit: number = 20): Promise<MessageEntity[]> {
    const stmt = this.db.prepare(`
      SELECT m.*
      FROM messages_fts
      JOIN messages m ON messages_fts.rowid = m.rowid
      WHERE messages_fts MATCH ?
      ORDER BY rank
      LIMIT ?
    `);
    
    const rows = stmt.all(searchQuery, limit);
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Delete all messages in conversation
  async deleteByConversation(conversationId: string): Promise<number> {
    const stmt = this.db.prepare('DELETE FROM messages WHERE conversation_id = ?');
    const result = stmt.run(conversationId);
    return result.changes;
  }
}

// ==========================================
// 6. DB CONTEXT (Entity Framework DbContext equivalent)
// ==========================================
// File: apps/workbench-desktop/src/api/entities/DbContext.ts

import Database from 'better-sqlite3';
import { ProviderRepository } from './Provider.repository';
import { AgentRepository } from './Agent.repository';
import { ConversationRepository } from './Conversation.repository';
import { MessageRepository } from './Message.repository';

export class DbContext {
  private static instance: DbContext;
  private db: Database.Database;

  // Repositories (like DbSets in EF)
  public providers: ProviderRepository;
  public agents: AgentRepository;
  public conversations: ConversationRepository;
  public messages: MessageRepository;

  private constructor(dbPath: string = 'workbench.db') {
    this.db = new Database(dbPath);
    this.db.pragma('foreign_keys = ON');
    
    // Initialize repositories
    this.providers = new ProviderRepository(this.db);
    this.agents = new AgentRepository(this.db);
    this.conversations = new ConversationRepository(this.db);
    this.messages = new MessageRepository(this.db);
  }

  static getInstance(dbPath?: string): DbContext {
    if (!DbContext.instance) {
      DbContext.instance = new DbContext(dbPath);
    }
    return DbContext.instance;
  }

  // Transaction support (like EF's SaveChanges)
  transaction<T>(callback: () => T): T {
    const transaction = this.db.transaction(callback);
    return transaction();
  }

  // Async transaction
  async transactionAsync<T>(callback: () => Promise<T>): Promise<T> {
    this.db.prepare('BEGIN').run();
    try {
      const result = await callback();
      this.db.prepare('COMMIT').run();
      return result;
    } catch (error) {
      this.db.prepare('ROLLBACK').run();
      throw error;
    }
  }

  // Close database connection
  close(): void {
    this.db.close();
  }
}

// ==========================================
// 7. USAGE IN tRPC ROUTERS
// ==========================================
// File: apps/workbench-desktop/src/api/routers/provider.router.v2.ts

import { router, publicProcedure, protectedProcedure } from '../trpc/middleware';
import { createProviderSchema, updateProviderSchema } from '../schemas/provider.schema';
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { ProviderEntity, ProviderType } from '../entities/Provider.entity';

export const providerRouter = router({
  /**
   * List all providers using Entity Framework pattern
   */
  list: publicProcedure.query(async ({ ctx }) => {
    const providers = await ctx.dbContext.providers.findAll();
    return providers;
  }),

  /**
   * Get provider by ID
   */
  getById: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const provider = await ctx.dbContext.providers.findById(input.providerId);
      
      if (!provider) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Provider not found',
        });
      }
      
      // Use entity business logic method
      provider.addModel(input.model);
      
      // Save changes
      await ctx.dbContext.providers.update(provider);
      
      return provider;
    }),
});

// ==========================================
// 8. UPDATED TRPC CONTEXT
// ==========================================
// File: apps/workbench-desktop/src/api/trpc/context.ts

import { DbContext } from '../entities/DbContext';
import { inferAsyncReturnType } from '@trpc/server';

export interface Context {
  dbContext: DbContext; // Entity Framework-style context
  userId?: string;
  requestId: string;
}

export const createContext = async (): Promise<Context> => {
  const dbContext = DbContext.getInstance();
  
  return {
    dbContext,
    requestId: crypto.randomUUID(),
  };
};

export type TRPCContext = inferAsyncReturnType<typeof createContext>;

// ==========================================
// 9. EXAMPLE: Complex Transaction with Multiple Entities
// ==========================================
// File: apps/workbench-desktop/src/api/services/conversation.service.ts

import { DbContext } from '../entities/DbContext';
import { ConversationEntity } from '../entities/Conversation.entity';
import { MessageEntity, MessageRole } from '../entities/Message.entity';

export class ConversationService {
  constructor(private dbContext: DbContext) {}

  /**
   * Create conversation with initial message (transactional)
   */
  async createWithMessage(
    title: string,
    agentIds: string[],
    initialMessage: string
  ): Promise<{ conversation: ConversationEntity; message: MessageEntity }> {
    return this.dbContext.transactionAsync(async () => {
      // Create conversation entity
      const conversation = new ConversationEntity({
        title,
        agentIds,
      });
      
      await this.dbContext.conversations.create(conversation);
      
      // Create initial message entity
      const message = new MessageEntity({
        conversationId: conversation.id,
        role: MessageRole.USER,
        content: initialMessage,
      });
      
      await this.dbContext.messages.create(message);
      
      return { conversation, message };
    });
  }

  /**
   * Add message to conversation and update conversation timestamp
   */
  async addMessage(
    conversationId: string,
    role: MessageRole,
    content: string
  ): Promise<MessageEntity> {
    return this.dbContext.transactionAsync(async () => {
      // Load conversation
      const conversation = await this.dbContext.conversations.findById(conversationId);
      
      if (!conversation) {
        throw new Error('Conversation not found');
      }
      
      // Create message
      const message = new MessageEntity({
        conversationId,
        role,
        content,
      });
      
      await this.dbContext.messages.create(message);
      
      // Update conversation timestamp
      conversation.markModified();
      await this.dbContext.conversations.update(conversation);
      
      return message;
    });
  }

  /**
   * Delete conversation with all messages (cascading in transaction)
   */
  async deleteConversation(conversationId: string): Promise<void> {
    this.dbContext.transaction(() => {
      // Delete all messages first
      this.dbContext.messages.deleteByConversation(conversationId);
      
      // Delete conversation
      this.dbContext.conversations.delete(conversationId);
    });
  }
}

// ==========================================
// 10. EXAMPLE: Using the Service in Router
// ==========================================
// File: apps/workbench-desktop/src/api/routers/chat.router.v2.ts

import { router, protectedProcedure } from '../trpc/middleware';
import { ConversationService } from '../services/conversation.service';
import { MessageRole } from '../entities/Message.entity';
import { z } from 'zod';

export const chatRouter = router({
  createWithMessage: protectedProcedure
    .input(z.object({
      title: z.string(),
      agentIds: z.array(z.string().uuid()),
      initialMessage: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      const service = new ConversationService(ctx.dbContext);
      
      const result = await service.createWithMessage(
        input.title,
        input.agentIds,
        input.initialMessage
      );
      
      return result;
    }),
    
  sendMessage: protectedProcedure
    .input(z.object({
      conversationId: z.string().uuid(),
      role: z.nativeEnum(MessageRole),
      content: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      const service = new ConversationService(ctx.dbContext);
      
      const message = await service.addMessage(
        input.conversationId,
        input.role,
        input.content
      );
      
      return message;
    }),
});

// ==========================================
// 11. EXAMPLE: Query with Relations (Like EF Include)
// ==========================================

// In Agent.repository.ts - add this method:
export class AgentRepositoryExtended extends AgentRepository {
  /**
   * Find agent with its provider (like EF's Include)
   */
  async findWithProvider(agentId: string) {
    const agent = await this.findById(agentId);
    if (!agent) return null;
    
    const providerRepo = new ProviderRepository(this.db);
    const provider = await providerRepo.findById(agent.modelId);
    
    return {
      ...agent,
      provider,
    };
  }
  
  /**
   * Find all agents with their providers (eager loading)
   */
  async findAllWithProviders() {
    const agents = await this.findAll();
    const providerRepo = new ProviderRepository(this.db);
    
    const agentsWithProviders = await Promise.all(
      agents.map(async (agent) => {
        const provider = await providerRepo.findById(agent.modelId);
        return { ...agent, provider };
      })
    );
    
    return agentsWithProviders;
  }
}

// ==========================================
// 12. SUMMARY OF ENTITY FRAMEWORK PATTERN
// ==========================================

/*
KEY CONCEPTS FROM C# ENTITY FRAMEWORK IMPLEMENTED:

1. ‚úÖ **DbContext**: Central hub for all database operations (DbContext.ts)
2. ‚úÖ **DbSets**: Repository pattern for each entity type (providers, agents, etc.)
3. ‚úÖ **Entities**: Classes that map to database tables with validation
4. ‚úÖ **Transactions**: SaveChanges-like behavior with rollback support
5. ‚úÖ **Navigation Properties**: Relations between entities
6. ‚úÖ **Lazy/Eager Loading**: findWithProvider, findAllWithProviders
7. ‚úÖ **LINQ-like Queries**: findWhere, findByRole, etc.
8. ‚úÖ **Change Tracking**: markModified() method
9. ‚úÖ **Validation**: validate() method on entities
10. ‚úÖ **Business Logic**: Entity methods (addModel, toggleActive, etc.)

USAGE PATTERN:

// In your tRPC router:
const provider = await ctx.dbContext.providers.findById(id);
provider.addModel(newModel);
await ctx.dbContext.providers.update(provider);

// Transaction:
ctx.dbContext.transaction(() => {
  ctx.dbContext.providers.create(provider);
  ctx.dbContext.agents.create(agent);
});

This gives you the same developer experience as C# Entity Framework!
*/.dbContext.providers.findById(input.id);
      
      if (!provider) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      return provider;
    }),

  /**
   * Create new provider using Entity
   */
  create: protectedProcedure
    .input(createProviderSchema)
    .mutation(async ({ ctx, input }) => {
      // Create entity instance
      const provider = new ProviderEntity({
        name: input.name,
        type: input.type as ProviderType,
        endpoint: input.endpoint,
        apiKey: input.apiKey,
        models: input.models,
        metadata: input.metadata || {},
      });
      
      // Validate entity
      provider.validate();
      
      // Save to database
      const saved = await ctx.dbContext.providers.create(provider);
      
      return saved;
    }),

  /**
   * Update provider using Entity
   */
  update: protectedProcedure
    .input(updateProviderSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;
      
      // Load existing entity
      const provider = await ctx.dbContext.providers.findById(id);
      
      if (!provider) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${id} not found`,
        });
      }
      
      // Update entity properties
      if (updates.name) provider.name = updates.name;
      if (updates.type) provider.type = updates.type as ProviderType;
      if (updates.endpoint !== undefined) provider.endpoint = updates.endpoint;
      if (updates.apiKey !== undefined) provider.apiKey = updates.apiKey;
      if (updates.models) provider.models = updates.models;
      if (updates.metadata) provider.metadata = updates.metadata;
      
      // Save changes
      const updated = await ctx.dbContext.providers.update(provider);
      
      return updated;
    }),

  /**
   * Delete provider with business logic
   */
  delete: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // Check if any agents are using this provider
      const hasAgents = await ctx.dbContext.providers.hasActiveAgents(input.id);
      
      if (hasAgents) {
        throw new TRPCError({
          code: 'PRECONDITION_FAILED',
          message: 'Cannot delete provider: agents are using it',
        });
      }
      
      const deleted = await ctx.dbContext.providers.delete(input.id);
      
      if (!deleted) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Provider with ID ${input.id} not found`,
        });
      }
      
      return { success: true, deletedId: input.id };
    }),

  /**
   * Add model to provider using entity method
   */
  addModel: protectedProcedure
    .input(z.object({
      providerId: z.string().uuid(),
      model: z.object({
        id: z.string(),
        name: z.string(),
        contextWindow: z.number().optional(),
        maxTokens: z.number().optional(),
      }),
    }))
    .mutation(async ({ ctx, input }) => {
      const provider = await ctx


# üèóÔ∏è Entity Framework Setup Guide

## Complete TypeScript Entity Framework Implementation

This guide shows you how to implement a C#-style Entity Framework pattern in your Node.js/TypeScript tRPC backend.

---

## üìÅ Project Structure

```
apps/workbench-desktop/src/api/
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îú‚îÄ‚îÄ base/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BaseEntity.ts           # Abstract base class for all entities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BaseRepository.ts       # Generic repository with CRUD
‚îÇ   ‚îú‚îÄ‚îÄ Provider.entity.ts          # Provider domain model
‚îÇ   ‚îú‚îÄ‚îÄ Provider.repository.ts      # Provider-specific queries
‚îÇ   ‚îú‚îÄ‚îÄ Agent.entity.ts             # Agent domain model
‚îÇ   ‚îú‚îÄ‚îÄ Agent.repository.ts         # Agent-specific queries
‚îÇ   ‚îú‚îÄ‚îÄ Conversation.entity.ts      # Conversation domain model
‚îÇ   ‚îú‚îÄ‚îÄ Conversation.repository.ts  # Conversation queries
‚îÇ   ‚îú‚îÄ‚îÄ Message.entity.ts           # Message domain model
‚îÇ   ‚îú‚îÄ‚îÄ Message.repository.ts       # Message queries
‚îÇ   ‚îî‚îÄ‚îÄ DbContext.ts                # Central database context (like EF DbContext)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ conversation.service.ts     # Business logic layer
‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îú‚îÄ‚îÄ provider.router.ts          # tRPC routes using entities
‚îÇ   ‚îú‚îÄ‚îÄ agent.router.ts
‚îÇ   ‚îî‚îÄ‚îÄ chat.router.ts
‚îî‚îÄ‚îÄ trpc/
    ‚îî‚îÄ‚îÄ context.ts                  # Updated to include DbContext
```

---

## üöÄ Step-by-Step Implementation

### **Step 1: Install Dependencies**

```bash
npm install better-sqlite3 @types/better-sqlite3
npm install zod @trpc/server
```

### **Step 2: Create Base Classes**

These provide the foundation for all entities:

#### `BaseEntity.ts`
- Abstract base class with common fields (id, createdAt, updatedAt)
- Validation hooks
- Change tracking (markModified)
- Database serialization

#### `BaseRepository.ts`
- Generic CRUD operations (findById, findAll, create, update, delete)
- Transaction support
- Type-safe query methods
- Works with any entity that extends BaseEntity

### **Step 3: Create Your Entities**

Each entity represents a database table:

```typescript
// Example: Provider.entity.ts
export class ProviderEntity extends BaseEntity {
  name: string;
  type: ProviderType;
  models: ModelInfo[];
  
  // Validation logic
  validate(): void {
    if (!this.name) throw new Error('Name required');
  }
  
  // Business logic
  addModel(model: ModelInfo): void {
    this.models.push(model);
    this.markModified();
  }
  
  // Database mapping
  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      models: JSON.stringify(this.models),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }
}
```

**Key Features:**
- ‚úÖ Strong typing
- ‚úÖ Built-in validation
- ‚úÖ Business logic methods
- ‚úÖ Automatic change tracking
- ‚úÖ JSON serialization for complex types

### **Step 4: Create Repositories**

Each repository provides database access for an entity:

```typescript
// Example: Provider.repository.ts
export class ProviderRepository extends BaseRepository<ProviderEntity> {
  constructor(db: Database) {
    super(db, 'providers', ProviderEntity);
  }
  
  // Map database row to entity
  protected mapRowToEntity(row: any): ProviderEntity {
    return new ProviderEntity({
      id: row.id,
      name: row.name,
      type: row.type,
      models: JSON.parse(row.models),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }
  
  // Map entity to database row
  protected mapEntityToRow(entity: ProviderEntity) {
    return entity.toDatabase();
  }
  
  // Custom queries
  async findByType(type: ProviderType): Promise<ProviderEntity[]> {
    return this.findWhere({ type });
  }
}
```

### **Step 5: Create DbContext**

The central hub for all database operations:

```typescript
// DbContext.ts
export class DbContext {
  private db: Database;
  
  // DbSets (like EF)
  public providers: ProviderRepository;
  public agents: AgentRepository;
  public conversations: ConversationRepository;
  public messages: MessageRepository;
  
  constructor(dbPath: string = 'workbench.db') {
    this.db = new Database(dbPath);
    this.db.pragma('foreign_keys = ON');
    
    // Initialize repositories
    this.providers = new ProviderRepository(this.db);
    this.agents = new AgentRepository(this.db);
    this.conversations = new ConversationRepository(this.db);
    this.messages = new MessageRepository(this.db);
  }
  
  // Transaction support (like SaveChanges)
  transaction<T>(callback: () => T): T {
    return this.db.transaction(callback)();
  }
  
  async transactionAsync<T>(callback: () => Promise<T>): Promise<T> {
    this.db.prepare('BEGIN').run();
    try {
      const result = await callback();
      this.db.prepare('COMMIT').run();
      return result;
    } catch (error) {
      this.db.prepare('ROLLBACK').run();
      throw error;
    }
  }
}
```

### **Step 6: Update tRPC Context**

Make DbContext available in all routes:

```typescript
// trpc/context.ts
import { DbContext } from '../entities/DbContext';

export interface Context {
  dbContext: DbContext;  // ‚Üê Your Entity Framework context
  userId?: string;
  requestId: string;
}

export const createContext = async (): Promise<Context> => {
  return {
    dbContext: DbContext.getInstance(),
    requestId: crypto.randomUUID(),
  };
};
```

### **Step 7: Use Entities in Routers**

Now your routers work with entities, not raw SQL:

```typescript
// provider.router.ts
export const providerRouter = router({
  list: publicProcedure.query(async ({ ctx }) => {
    // No SQL! Just use the repository
    return await ctx.dbContext.providers.findAll();
  }),
  
  create: protectedProcedure
    .input(createProviderSchema)
    .mutation(async ({ ctx, input }) => {
      // Create entity instance
      const provider = new ProviderEntity({
        name: input.name,
        type: input.type,
        models: input.models,
      });
      
      // Validate
      provider.validate();
      
      // Save to database
      return await ctx.dbContext.providers.create(provider);
    }),
    
  update: protectedProcedure
    .input(updateProviderSchema)
    .mutation(async ({ ctx, input }) => {
      // Load entity
      const provider = await ctx.dbContext.providers.findById(input.id);
      if (!provider) throw new Error('Not found');
      
      // Update properties
      provider.name = input.name;
      provider.models = input.models;
      
      // Save changes (like EF's SaveChanges)
      return await ctx.dbContext.providers.update(provider);
    }),
    
  addModel: protectedProcedure
    .input(addModelSchema)
    .mutation(async ({ ctx, input }) => {
      const provider = await ctx.dbContext.providers.findById(input.providerId);
      
      // Use entity's business logic method
      provider.addModel(input.model);
      
      // Save
      await ctx.dbContext.providers.update(provider);
      return provider;
    }),
});
```

---

## üéØ Key Patterns & Best Practices

### 1. **Entity Design**

```typescript
export class AgentEntity extends BaseEntity {
  // Properties (map to database columns)
  name: string;
  role: AgentRole;
  isActive: boolean;
  
  // Validation
  validate(): void {
    super.validate();
    if (!this.name) throw new Error('Name required');
    if (this.temperature < 0 || this.temperature > 2) {
      throw new Error('Temperature must be 0-2');
    }
  }
  
  // Business Logic Methods
  activate(): void {
    this.isActive = true;
    this.markModified();
  }
  
  deactivate(): void {
    this.isActive = false;
    this.markModified();
  }
  
  toggleActive(): void {
    this.isActive = !this.isActive;
    this.markModified();
  }
  
  // Database Mapping
  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      role: this.role,
      is_active: this.isActive ? 1 : 0,
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }
}
```

**Benefits:**
- ‚úÖ All business logic in one place
- ‚úÖ Validation before save
- ‚úÖ Type-safe operations
- ‚úÖ Easy to test

### 2. **Repository Queries**

```typescript
export class AgentRepository extends BaseRepository<AgentEntity> {
  // Simple queries
  async findByRole(role: AgentRole) {
    return this.findWhere({ role });
  }
  
  async findActive() {
    return this.findWhere({ is_active: 1 });
  }
  
  // Complex queries with joins
  async findWithProvider(agentId: string) {
    const stmt = this.db.prepare(`
      SELECT a.*, p.name as provider_name
      FROM agents a
      JOIN providers p ON a.model_id = p.id
      WHERE a.id = ?
    `);
    
    const row = stmt.get(agentId);
    if (!row) return null;
    
    const agent = this.mapRowToEntity(row);
    return {
      ...agent,
      providerName: row.provider_name,
    };
  }
  
  // Aggregate queries
  async getStatistics() {
    const stmt = this.db.prepare(`
      SELECT 
        role,
        COUNT(*) as count,
        SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active_count
      FROM agents
      GROUP BY role
    `);
    
    return stmt.all();
  }
}
```

### 3. **Service Layer (Business Logic)**

Create services for complex operations:

```typescript
// conversation.service.ts
export class ConversationService {
  constructor(private dbContext: DbContext) {}
  
  async createWithMessage(
    title: string,
    agentIds: string[],
    initialMessage: string
  ) {
    // Transaction ensures both succeed or both fail
    return this.dbContext.transactionAsync(async () => {
      // Create conversation
      const conversation = new ConversationEntity({ title, agentIds });
      await this.dbContext.conversations.create(conversation);
      
      // Create initial message
      const message = new MessageEntity({
        conversationId: conversation.id,
        role: MessageRole.USER,
        content: initialMessage,
      });
      await this.dbContext.messages.create(message);
      
      return { conversation, message };
    });
  }
  
  async deleteWithMessages(conversationId: string) {
    this.dbContext.transaction(() => {
      // Delete messages first (order matters with foreign keys)
      this.dbContext.messages.deleteByConversation(conversationId);
      this.dbContext.conversations.delete(conversationId);
    });
  }
}
```

### 4. **Transaction Examples**

```typescript
// Simple transaction
ctx.dbContext.transaction(() => {
  const provider = new ProviderEntity({ name: 'Test' });
  ctx.dbContext.providers.create(provider);
  
  const agent = new AgentEntity({ 
    name: 'Bot',
    modelId: provider.id 
  });
  ctx.dbContext.agents.create(agent);
});

// Async transaction
await ctx.dbContext.transactionAsync(async () => {
  const conversation = await ctx.dbContext.conversations.create(conv);
  const message = await ctx.dbContext.messages.create(msg);
  return { conversation, message };
});
```

### 5. **Relations (Like EF Include)**

```typescript
// Eager loading - load related entities
async findAgentWithProvider(agentId: string) {
  const agent = await ctx.dbContext.agents.findById(agentId);
  if (!agent) return null;
  
  const provider = await ctx.dbContext.providers.findById(agent.modelId);
  
  return { agent, provider };
}

// Lazy loading - load when needed
class AgentEntity {
  private _provider?: ProviderEntity;
  
  async getProvider(dbContext: DbContext): Promise<ProviderEntity | null> {
    if (!this._provider) {
      this._provider = await dbContext.providers.findById(this.modelId);
    }
    return this._provider;
  }
}
```

---

## üß™ Testing Entities

```typescript
// agent.entity.test.ts
describe('AgentEntity', () => {
  it('should validate required fields', () => {
    const agent = new AgentEntity({
      name: '',
      role: AgentRole.CODER,
    });
    
    expect(() => agent.validate()).toThrow('Name required');
  });
  
  it('should toggle active status', () => {
    const agent = new AgentEntity({
      name: 'Test',
      isActive: true,
    });
    
    agent.toggleActive();
    expect(agent.isActive).toBe(false);
  });
  
  it('should mark as modified when changed', () => {
    const agent = new AgentEntity({ name: 'Test' });
    const originalTimestamp = agent.updatedAt;
    
    // Wait a bit
    setTimeout(() => {
      agent.name = 'New Name';
      agent.markModified();
      
      expect(agent.updatedAt).toBeGreaterThan(originalTimestamp);
    }, 10);
  });
});

// agent.repository.test.ts
describe('AgentRepository', () => {
  let db: Database;
  let repo: AgentRepository;
  
  beforeEach(() => {
    db = new Database(':memory:');
    // Run schema
    repo = new AgentRepository(db);
  });
  
  it('should create and retrieve agent', async () => {
    const agent = new AgentEntity({
      name: 'Test Agent',
      role: AgentRole.CODER,
    });
    
    await repo.create(agent);
    const retrieved = await repo.findById(agent.id);
    
    expect(retrieved).toBeTruthy();
    expect(retrieved?.name).toBe('Test Agent');
  });
  
  it('should update agent', async () => {
    const agent = new AgentEntity({ name: 'Original' });
    await repo.create(agent);
    
    agent.name = 'Updated';
    await repo.update(agent);
    
    const retrieved = await repo.findById(agent.id);
    expect(retrieved?.name).toBe('Updated');
  });
});
```

---

## üìä Comparison: Entity Framework vs Direct SQL

### ‚ùå Without Entity Framework (Raw SQL)
```typescript
// Hard to maintain, no type safety, business logic scattered
const rows = await db.query(`
  UPDATE providers SET name = ?, models = ?, updated_at = ? WHERE id = ?
`, [name, JSON.stringify(models), Date.now(), id]);

// No validation
// No business logic
// Error-prone
```

### ‚úÖ With Entity Framework (Clean & Type-Safe)
```typescript
// Load entity
const provider = await ctx.dbContext.providers.findById(id);

// Update with validation
provider.name = name;
provider.addModel(newModel);  // Business logic

// Save
await ctx.dbContext.providers.update(provider);
// Automatic: validation, timestamps, serialization
```

---

## üéâ Benefits Summary

| Feature | Without EF | With EF |
|---------|-----------|---------|
| Type Safety | ‚ùå Manual | ‚úÖ Automatic |
| Validation | ‚ùå Manual | ‚úÖ Built-in |
| Business Logic | ‚ùå Scattered | ‚úÖ Centralized |
| Change Tracking | ‚ùå Manual | ‚úÖ Automatic |
| Transactions | ‚ùå Complex | ‚úÖ Simple |
| Testing | ‚ùå Hard | ‚úÖ Easy |
| Relations | ‚ùå Manual joins | ‚úÖ Methods |
| Maintenance | ‚ùå Hard | ‚úÖ Easy |

---

## üöÄ Migration from Your Current Code

1. **Create entities** for each table (Provider, Agent, Conversation, Message)
2. **Create repositories** for each entity
3. **Update DbContext** to include all repositories
4. **Update tRPC context** to inject DbContext
5. **Refactor routers** to use entities instead of raw SQL
6. **Add service layer** for complex business logic
7. **Write tests** for entities and repositories

**You're now using Entity Framework patterns in TypeScript!** üéä

// ==========================================
// ADVANCED ENTITY FRAMEWORK PATTERNS
// Many-to-Many, Computed Properties, Soft Deletes, and More
// ==========================================

// ==========================================
// 1. MANY-TO-MANY RELATIONSHIP PATTERN
// ==========================================
// Example: Agents can work on multiple Projects, Projects can have multiple Agents

// File: apps/workbench-desktop/src/api/entities/Project.entity.ts

import { BaseEntity } from './base/BaseEntity';

export enum ProjectStatus {
  PLANNING = 'planning',
  IN_PROGRESS = 'in_progress',
  REVIEW = 'review',
  COMPLETED = 'completed',
  ARCHIVED = 'archived',
}

export class ProjectEntity extends BaseEntity {
  name: string;
  description: string;
  status: ProjectStatus;
  repositoryPath?: string;
  metadata: Record<string, any>;

  constructor(data: Partial<ProjectEntity>) {
    super(data);
    this.name = data.name || '';
    this.description = data.description || '';
    this.status = data.status || ProjectStatus.PLANNING;
    this.repositoryPath = data.repositoryPath;
    this.metadata = data.metadata || {};
  }

  validate(): void {
    super.validate();
    if (!this.name || this.name.length === 0) {
      throw new Error('Project name is required');
    }
    if (this.name.length > 200) {
      throw new Error('Project name must be less than 200 characters');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      status: this.status,
      repository_path: this.repositoryPath || null,
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  // Business logic
  startProject(): void {
    if (this.status !== ProjectStatus.PLANNING) {
      throw new Error('Can only start projects in planning status');
    }
    this.status = ProjectStatus.IN_PROGRESS;
    this.markModified();
  }

  completeProject(): void {
    if (this.status !== ProjectStatus.REVIEW) {
      throw new Error('Project must be in review before completion');
    }
    this.status = ProjectStatus.COMPLETED;
    this.markModified();
  }
}

// File: apps/workbench-desktop/src/api/entities/ProjectAgent.entity.ts
// Junction table entity for many-to-many relationship

export enum AgentProjectRole {
  LEAD = 'lead',
  CONTRIBUTOR = 'contributor',
  REVIEWER = 'reviewer',
}

export class ProjectAgentEntity {
  projectId: string;
  agentId: string;
  role: AgentProjectRole;
  assignedAt: number;
  hoursWorked: number;
  metadata: Record<string, any>;

  constructor(data: Partial<ProjectAgentEntity>) {
    this.projectId = data.projectId || '';
    this.agentId = data.agentId || '';
    this.role = data.role || AgentProjectRole.CONTRIBUTOR;
    this.assignedAt = data.assignedAt || Date.now();
    this.hoursWorked = data.hoursWorked || 0;
    this.metadata = data.metadata || {};
  }

  validate(): void {
    if (!this.projectId) throw new Error('Project ID is required');
    if (!this.agentId) throw new Error('Agent ID is required');
  }

  toDatabase(): Record<string, any> {
    return {
      project_id: this.projectId,
      agent_id: this.agentId,
      role: this.role,
      assigned_at: this.assignedAt,
      hours_worked: this.hoursWorked,
      metadata: JSON.stringify(this.metadata),
    };
  }

  // Business logic
  incrementHours(hours: number): void {
    this.hoursWorked += hours;
  }

  promoteToLead(): void {
    this.role = AgentProjectRole.LEAD;
  }
}

// File: apps/workbench-desktop/src/api/entities/Project.repository.ts

import { BaseRepository } from './base/BaseRepository';
import { ProjectEntity, ProjectStatus } from './Project.entity';
import { ProjectAgentEntity } from './ProjectAgent.entity';
import { AgentEntity } from './Agent.entity';
import { Database } from 'better-sqlite3';

export class ProjectRepository extends BaseRepository<ProjectEntity> {
  constructor(db: Database.Database) {
    super(db, 'projects', ProjectEntity);
  }

  protected mapRowToEntity(row: any): ProjectEntity {
    return new ProjectEntity({
      id: row.id,
      name: row.name,
      description: row.description,
      status: row.status as ProjectStatus,
      repositoryPath: row.repository_path,
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: ProjectEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Many-to-many: Get project with all assigned agents
  async findWithAgents(projectId: string): Promise<{
    project: ProjectEntity;
    agents: Array<AgentEntity & { role: AgentProjectRole; hoursWorked: number }>;
  } | null> {
    const project = await this.findById(projectId);
    if (!project) return null;

    const stmt = this.db.prepare(`
      SELECT 
        a.*,
        pa.role,
        pa.hours_worked,
        pa.assigned_at
      FROM project_agents pa
      JOIN agents a ON pa.agent_id = a.id
      WHERE pa.project_id = ?
      ORDER BY pa.assigned_at DESC
    `);

    const rows = stmt.all(projectId);
    const agents = rows.map(row => ({
      ...new AgentEntity({
        id: row.id,
        name: row.name,
        role: row.role,
        // ... other agent fields
      }),
      role: row.role as AgentProjectRole,
      hoursWorked: row.hours_worked,
      assignedAt: row.assigned_at,
    }));

    return { project, agents };
  }

  // Get all projects for a specific agent
  async findByAgent(agentId: string): Promise<ProjectEntity[]> {
    const stmt = this.db.prepare(`
      SELECT p.*
      FROM projects p
      JOIN project_agents pa ON p.id = pa.project_id
      WHERE pa.agent_id = ?
      ORDER BY pa.assigned_at DESC
    `);

    const rows = stmt.all(agentId);
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Assign agent to project
  async assignAgent(
    projectId: string,
    agentId: string,
    role: AgentProjectRole = AgentProjectRole.CONTRIBUTOR
  ): Promise<void> {
    const assignment = new ProjectAgentEntity({
      projectId,
      agentId,
      role,
    });

    assignment.validate();

    const stmt = this.db.prepare(`
      INSERT INTO project_agents (project_id, agent_id, role, assigned_at, hours_worked, metadata)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    const data = assignment.toDatabase();
    stmt.run(
      data.project_id,
      data.agent_id,
      data.role,
      data.assigned_at,
      data.hours_worked,
      data.metadata
    );
  }

  // Remove agent from project
  async unassignAgent(projectId: string, agentId: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM project_agents
      WHERE project_id = ? AND agent_id = ?
    `);

    const result = stmt.run(projectId, agentId);
    return result.changes > 0;
  }

  // Get project statistics
  async getStatistics(projectId: string): Promise<{
    totalAgents: number;
    totalHours: number;
    taskCount: number;
  }> {
    const stmt = this.db.prepare(`
      SELECT 
        COUNT(DISTINCT pa.agent_id) as total_agents,
        SUM(pa.hours_worked) as total_hours,
        (SELECT COUNT(*) FROM tasks WHERE project_id = ?) as task_count
      FROM project_agents pa
      WHERE pa.project_id = ?
    `);

    const result = stmt.get(projectId, projectId) as any;
    return {
      totalAgents: result.total_agents || 0,
      totalHours: result.total_hours || 0,
      taskCount: result.task_count || 0,
    };
  }
}

// ==========================================
// 2. SOFT DELETE PATTERN
// ==========================================
// File: apps/workbench-desktop/src/api/entities/base/SoftDeletableEntity.ts

export abstract class SoftDeletableEntity extends BaseEntity {
  deletedAt?: number;
  isDeleted: boolean;

  constructor(data?: Partial<SoftDeletableEntity>) {
    super(data);
    this.deletedAt = data?.deletedAt;
    this.isDeleted = data?.isDeleted || false;
  }

  // Soft delete - mark as deleted but don't remove from DB
  softDelete(): void {
    this.isDeleted = true;
    this.deletedAt = Date.now();
    this.markModified();
  }

  // Restore soft-deleted entity
  restore(): void {
    this.isDeleted = false;
    this.deletedAt = undefined;
    this.markModified();
  }

  // Check if entity is deleted
  isActive(): boolean {
    return !this.isDeleted;
  }

  toDatabase(): Record<string, any> {
    return {
      ...super.toDatabase(),
      deleted_at: this.deletedAt || null,
      is_deleted: this.isDeleted ? 1 : 0,
    };
  }
}

// File: apps/workbench-desktop/src/api/entities/base/SoftDeletableRepository.ts

export abstract class SoftDeletableRepository<T extends SoftDeletableEntity> extends BaseRepository<T> {
  // Override findAll to exclude deleted by default
  async findAll(includeDeleted: boolean = false): Promise<T[]> {
    let query = `SELECT * FROM ${this.tableName}`;
    
    if (!includeDeleted) {
      query += ' WHERE is_deleted = 0';
    }
    
    const stmt = this.db.prepare(query);
    const rows = stmt.all();
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Override findById to exclude deleted by default
  async findById(id: string, includeDeleted: boolean = false): Promise<T | null> {
    let query = `SELECT * FROM ${this.tableName} WHERE id = ?`;
    
    if (!includeDeleted) {
      query += ' AND is_deleted = 0';
    }
    
    const stmt = this.db.prepare(query);
    const row = stmt.get(id);
    
    if (!row) return null;
    return this.mapRowToEntity(row);
  }

  // Soft delete instead of hard delete
  async softDelete(id: string): Promise<boolean> {
    const entity = await this.findById(id);
    if (!entity) return false;

    entity.softDelete();
    await this.update(entity);
    return true;
  }

  // Restore soft-deleted entity
  async restore(id: string): Promise<boolean> {
    const entity = await this.findById(id, true); // Include deleted
    if (!entity || !entity.isDeleted) return false;

    entity.restore();
    await this.update(entity);
    return true;
  }

  // Find only deleted entities
  async findDeleted(): Promise<T[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM ${this.tableName} WHERE is_deleted = 1
      ORDER BY deleted_at DESC
    `);
    
    const rows = stmt.all();
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Permanently delete (hard delete)
  async hardDelete(id: string): Promise<boolean> {
    return super.delete(id);
  }
}

// Example: Task entity with soft delete
// File: apps/workbench-desktop/src/api/entities/Task.entity.ts

export enum TaskStatus {
  TODO = 'todo',
  IN_PROGRESS = 'in_progress',
  BLOCKED = 'blocked',
  DONE = 'done',
}

export enum TaskPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}

export class TaskEntity extends SoftDeletableEntity {
  projectId: string;
  title: string;
  description: string;
  status: TaskStatus;
  priority: TaskPriority;
  assignedToAgentId?: string;
  estimatedHours?: number;
  actualHours?: number;
  dueDate?: number;
  completedAt?: number;

  constructor(data: Partial<TaskEntity>) {
    super(data);
    this.projectId = data.projectId || '';
    this.title = data.title || '';
    this.description = data.description || '';
    this.status = data.status || TaskStatus.TODO;
    this.priority = data.priority || TaskPriority.MEDIUM;
    this.assignedToAgentId = data.assignedToAgentId;
    this.estimatedHours = data.estimatedHours;
    this.actualHours = data.actualHours;
    this.dueDate = data.dueDate;
    this.completedAt = data.completedAt;
  }

  validate(): void {
    super.validate();
    if (!this.projectId) throw new Error('Project ID is required');
    if (!this.title || this.title.length === 0) {
      throw new Error('Task title is required');
    }
  }

  toDatabase(): Record<string, any> {
    return {
      ...super.toDatabase(),
      project_id: this.projectId,
      title: this.title,
      description: this.description,
      status: this.status,
      priority: this.priority,
      assigned_to_agent_id: this.assignedToAgentId || null,
      estimated_hours: this.estimatedHours || null,
      actual_hours: this.actualHours || null,
      due_date: this.dueDate || null,
      completed_at: this.completedAt || null,
    };
  }

  // Business logic
  assign(agentId: string): void {
    this.assignedToAgentId = agentId;
    this.markModified();
  }

  start(): void {
    if (this.status !== TaskStatus.TODO) {
      throw new Error('Can only start tasks in TODO status');
    }
    this.status = TaskStatus.IN_PROGRESS;
    this.markModified();
  }

  complete(actualHours: number): void {
    if (this.status !== TaskStatus.IN_PROGRESS) {
      throw new Error('Can only complete tasks in progress');
    }
    this.status = TaskStatus.DONE;
    this.actualHours = actualHours;
    this.completedAt = Date.now();
    this.markModified();
  }

  block(): void {
    this.status = TaskStatus.BLOCKED;
    this.markModified();
  }

  unblock(): void {
    if (this.status !== TaskStatus.BLOCKED) {
      throw new Error('Task is not blocked');
    }
    this.status = TaskStatus.TODO;
    this.markModified();
  }

  isOverdue(): boolean {
    if (!this.dueDate) return false;
    return Date.now() > this.dueDate && this.status !== TaskStatus.DONE;
  }

  getProgress(): number {
    if (!this.estimatedHours || !this.actualHours) return 0;
    return (this.actualHours / this.estimatedHours) * 100;
  }
}

// File: apps/workbench-desktop/src/api/entities/Task.repository.ts

export class TaskRepository extends SoftDeletableRepository<TaskEntity> {
  constructor(db: Database.Database) {
    super(db, 'tasks', TaskEntity);
  }

  protected mapRowToEntity(row: any): TaskEntity {
    return new TaskEntity({
      id: row.id,
      projectId: row.project_id,
      title: row.title,
      description: row.description,
      status: row.status as TaskStatus,
      priority: row.priority as TaskPriority,
      assignedToAgentId: row.assigned_to_agent_id,
      estimatedHours: row.estimated_hours,
      actualHours: row.actual_hours,
      dueDate: row.due_date,
      completedAt: row.completed_at,
      isDeleted: Boolean(row.is_deleted),
      deletedAt: row.deleted_at,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    });
  }

  protected mapEntityToRow(entity: TaskEntity): Record<string, any> {
    return entity.toDatabase();
  }

  // Find tasks by project
  async findByProject(projectId: string, includeDeleted: boolean = false): Promise<TaskEntity[]> {
    let query = `SELECT * FROM ${this.tableName} WHERE project_id = ?`;
    
    if (!includeDeleted) {
      query += ' AND is_deleted = 0';
    }
    
    query += ' ORDER BY priority DESC, due_date ASC';
    
    const stmt = this.db.prepare(query);
    const rows = stmt.all(projectId);
    
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Find tasks assigned to agent
  async findByAgent(agentId: string): Promise<TaskEntity[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM ${this.tableName}
      WHERE assigned_to_agent_id = ? AND is_deleted = 0
      ORDER BY priority DESC, due_date ASC
    `);
    
    const rows = stmt.all(agentId);
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Find overdue tasks
  async findOverdue(): Promise<TaskEntity[]> {
    const now = Date.now();
    const stmt = this.db.prepare(`
      SELECT * FROM ${this.tableName}
      WHERE due_date < ? AND status != ? AND is_deleted = 0
      ORDER BY due_date ASC
    `);
    
    const rows = stmt.all(now, TaskStatus.DONE);
    return rows.map(row => this.mapRowToEntity(row));
  }

  // Get task statistics for a project
  async getProjectTaskStats(projectId: string): Promise<{
    total: number;
    todo: number;
    inProgress: number;
    blocked: number;
    done: number;
    overdue: number;
  }> {
    const stmt = this.db.prepare(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN status = 'todo' THEN 1 ELSE 0 END) as todo,
        SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
        SUM(CASE WHEN status = 'blocked' THEN 1 ELSE 0 END) as blocked,
        SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as done,
        SUM(CASE WHEN due_date < ? AND status != 'done' THEN 1 ELSE 0 END) as overdue
      FROM ${this.tableName}
      WHERE project_id = ? AND is_deleted = 0
    `);
    
    const result = stmt.get(Date.now(), projectId) as any;
    return {
      total: result.total || 0,
      todo: result.todo || 0,
      inProgress: result.in_progress || 0,
      blocked: result.blocked || 0,
      done: result.done || 0,
      overdue: result.overdue || 0,
    };
  }
}

// ==========================================
// 3. COMPUTED/VIRTUAL PROPERTIES PATTERN
// ==========================================
// File: apps/workbench-desktop/src/api/entities/AgentExtended.entity.ts

import { AgentEntity } from './Agent.entity';

export class AgentExtendedEntity extends AgentEntity {
  // Virtual property - not stored in DB
  private _totalTasks?: number;
  private _completedTasks?: number;
  private _activeProjects?: number;

  // Getters for computed properties
  get totalTasks(): number | undefined {
    return this._totalTasks;
  }

  get completedTasks(): number | undefined {
    return this._completedTasks;
  }

  get activeProjects(): number | undefined {
    return this._activeProjects;
  }

  get completionRate(): number {
    if (!this._totalTasks || this._totalTasks === 0) return 0;
    return (this._completedTasks || 0) / this._totalTasks * 100;
  }

  get workloadLevel(): 'light' | 'moderate' | 'heavy' | 'overloaded' {
    const tasks = this._totalTasks || 0;
    if (tasks === 0) return 'light';
    if (tasks <= 3) return 'moderate';
    if (tasks <= 7) return 'heavy';
    return 'overloaded';
  }

  // Method to load computed properties
  async loadStatistics(db: Database.Database): Promise<void> {
    const stmt = db.prepare(`
      SELECT 
        COUNT(*) as total_tasks,
        SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as completed_tasks,
        COUNT(DISTINCT project_id) as active_projects
      FROM tasks
      WHERE assigned_to_agent_id = ? AND is_deleted = 0
    `);
    
    const stats = stmt.get(this.id) as any;
    this._totalTasks = stats.total_tasks || 0;
    this._completedTasks = stats.completed_tasks || 0;
    this._activeProjects = stats.active_projects || 0;
  }

  // Override toDatabase - don't include computed properties
  toDatabase(): Record<string, any> {
    return super.toDatabase();
  }
}

// ==========================================
// 4. INHERITANCE PATTERN (Table Per Type)
// ==========================================
// File: apps/workbench-desktop/src/api/entities/Notification.entity.ts

export enum NotificationType {
  TASK_ASSIGNED = 'task_assigned',
  TASK_COMPLETED = 'task_completed',
  PROJECT_UPDATED = 'project_updated',
  AGENT_MENTIONED = 'agent_mentioned',
  SYSTEM_ALERT = 'system_alert',
}

// Base notification class
export abstract class NotificationEntity extends BaseEntity {
  type: NotificationType;
  title: string;
  message: string;
  isRead: boolean;
  readAt?: number;
  targetUserId?: string; // For future multi-user support
  
  constructor(data: Partial<NotificationEntity>) {
    super(data);
    this.type = data.type || NotificationType.SYSTEM_ALERT;
    this.title = data.title || '';
    this.message = data.message || '';
    this.isRead = data.isRead || false;
    this.readAt = data.readAt;
    this.targetUserId = data.targetUserId;
  }

  validate(): void {
    super.validate();
    if (!this.title) throw new Error('Title is required');
    if (!this.message) throw new Error('Message is required');
  }

  markAsRead(): void {
    this.isRead = true;
    this.readAt = Date.now();
    this.markModified();
  }

  toDatabase(): Record<string, any> {
    return {
      id: this.id,
      type: this.type,
      title: this.title,
      message: this.message,
      is_read: this.isRead ? 1 : 0,
      read_at: this.readAt || null,
      target_user_id: this.targetUserId || null,
      created_at: this.createdAt,
      updated_at: this.updatedAt,
    };
  }

  abstract getActionUrl(): string;
}

// Specific notification types
export class TaskNotificationEntity extends NotificationEntity {
  taskId: string;
  projectId: string;

  constructor(data: Partial<TaskNotificationEntity>) {
    super(data);
    this.taskId = data.taskId || '';
    this.projectId = data.projectId || '';
  }

  toDatabase(): Record<string, any> {
    return {
      ...super.toDatabase(),
      task_id: this.taskId,
      project_id: this.projectId,
    };
  }

  getActionUrl(): string {
    return `/projects/${this.projectId}/tasks/${this.taskId}`;
  }
}

export class ProjectNotificationEntity extends NotificationEntity {
  projectId: string;

  constructor(data: Partial<ProjectNotificationEntity>) {
    super(data);
    this.projectId = data.projectId || '';
  }

  toDatabase(): Record<string, any> {
    return {
      ...super.toDatabase(),
      project_id: this.projectId,
    };
  }

  getActionUrl(): string {
    return `/projects/${this.projectId}`;
  }
}

// ==========================================
// 5. UPDATED DBCONTEXT WITH NEW ENTITIES
// ==========================================
// File: apps/workbench-desktop/src/api/entities/DbContext.ts (Extended)

import Database from 'better-sqlite3';
import { ProviderRepository } from './Provider.repository';
import { AgentRepository } from './Agent.repository';
import { ConversationRepository } from './Conversation.repository';
import { MessageRepository } from './Message.repository';
import { ProjectRepository } from './Project.repository';
import { TaskRepository } from './Task.repository';

export class DbContext {
  private static instance: DbContext;
  private db: Database.Database;

  // All repositories
  public providers: ProviderRepository;
  public agents: AgentRepository;
  public conversations: ConversationRepository;
  public messages: MessageRepository;
  public projects: ProjectRepository;
  public tasks: TaskRepository;

  private constructor(dbPath: string = 'workbench.db') {
    this.db = new Database(dbPath);
    this.db.pragma('foreign_keys = ON');
    
    // Initialize all repositories
    this.providers = new ProviderRepository(this.db);
    this.agents = new AgentRepository(this.db);
    this.conversations = new ConversationRepository(this.db);
    this.messages = new MessageRepository(this.db);
    this.projects = new ProjectRepository(this.db);
    this.tasks = new TaskRepository(this.db);
  }

  static getInstance(dbPath?: string): DbContext {
    if (!DbContext.instance) {
      DbContext.instance = new DbContext(dbPath);
    }
    return DbContext.instance;
  }

  transaction<T>(callback: () => T): T {
    const transaction = this.db.transaction(callback);
    return transaction();
  }

  async transactionAsync<T>(callback: () => Promise<T>): Promise<T> {
    this.db.prepare('BEGIN').run();
    try {
      const result = await callback();
      this.db.prepare('COMMIT').run();
      return result;
    } catch (error) {
      this.db.prepare('ROLLBACK').run();
      throw error;
    }
  }

  close(): void {
    this.db.close();
  }

  // Utility methods
  async healthCheck(): Promise<boolean> {
    try {
      this.db.prepare('SELECT 1').get();
      return true;
    } catch {
      return false;
    }
  }

  async getDatabaseStats(): Promise<{
    providers: number;
    agents: number;
    projects: number;
    tasks: number;
    conversations: number;
    messages: number;
  }> {
    return {
      providers: await this.providers.count(),
      agents: await this.agents.count(),
      projects: await this.projects.count(),
      tasks: await this.tasks.count(),
      conversations: await this.conversations.count(),
      messages: await this.messages.count(),
    };
  }
}

// ==========================================
// 6. DATABASE SCHEMA FOR NEW ENTITIES
// ==========================================

/*
-- Projects table
CREATE TABLE IF NOT EXISTS projects (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  status TEXT NOT NULL CHECK(status IN ('planning', 'in_progress', 'review', 'completed', 'archived')),
  repository_path TEXT,
  metadata TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_created_at ON projects(created_at DESC);

-- Project-Agent junction table (many-to-many)
CREATE TABLE IF NOT EXISTS project_agents (
  project_id TEXT NOT NULL,
  agent_id TEXT NOT NULL,
  role TEXT NOT NULL CHECK(role IN ('lead', 'contributor', 'reviewer')),
  assigned_at INTEGER NOT NULL,
  hours_worked REAL DEFAULT 0,
  metadata TEXT,
  PRIMARY KEY (project_id, agent_id),
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (agent_id) REFERENCES agents(id) ON DELETE CASCADE
);

CREATE INDEX idx_project_agents_project ON project_agents(project_id);
CREATE INDEX idx_project_agents_agent ON project_agents(agent_id);

-- Tasks table (with soft delete)
CREATE TABLE IF NOT EXISTS tasks (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  status TEXT NOT NULL CHECK(status IN ('todo', 'in_progress', 'blocked', 'done')),
  priority TEXT NOT NULL CHECK(priority IN ('low', 'medium', 'high', 'urgent')),
  assigned_to_agent_id TEXT,
  estimated_hours REAL,
  actual_hours REAL,
  due_date INTEGER,
  completed_at INTEGER,
  is_deleted INTEGER DEFAULT 0,
  deleted_at INTEGER,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (assigned_to_agent_id) REFERENCES agents(id) ON DELETE SET NULL
);

CREATE INDEX idx_tasks_project ON tasks(project_id);
CREATE INDEX idx_tasks_agent ON tasks(assigned_to_agent_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_priority ON tasks(priority);
CREATE INDEX idx_tasks


<parameter name="old_str">CREATE INDEX idx_tasks</parameter>
<parameter name="new_str">CREATE INDEX idx_tasks_deleted ON tasks(is_deleted);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
-- Notifications table
CREATE TABLE IF NOT EXISTS notifications (
id TEXT PRIMARY KEY,
type TEXT NOT NULL CHECK(type IN ('task_assigned', 'task_completed', 'project_updated', 'agent_mentioned', 'system_alert')),
title TEXT NOT NULL,
message TEXT NOT NULL,
is_read INTEGER DEFAULT 0,
read_at INTEGER,
target_user_id TEXT,
task_id TEXT,
project_id TEXT,
created_at INTEGER NOT NULL,
updated_at INTEGER NOT NULL,
FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_read ON notifications(is_read);
CREATE INDEX idx_notifications_user ON notifications(target_user_id);
CREATE INDEX idx_notifications_created ON notifications(created_at DESC);
*/</parameter>

